scope testScope {
  shader vertex, pixel:
    descriptor_set(1);
    register(texture, 1-5);
    cbuffer(1);

  texture2D myvar = extern(someVar);
  texture2D myvar2 = extern(someVar);

  int lol = extern(kek);
};

scope testSomeScope {
  shader vertex, pixel:
    descriptor_set(1);
    register(texture, 1-5);
    cbuffer(1);

  int lol2 = extern(kek);
};

technique mytechnique {
  support scope testScope;
  activate scope testSomeScope;

  render_state:
    primitive_topology = triangle_list;
    input:
      buffer(0):
        float2 k1;
        float3 k2;
      buffer(1):
        int b;
    depth:
      test = yes;
      write = true;
      compare_op = always;
    stencil:
      test = no;
      fail_op = keep;
      pass_op = keep;
      depth_fail_op = keep;
      compare_op = never;
      ref_val = 0;
    blending:
      logic_op_enabled = yes;
      logic_op = and;
      blend_constants = float4(0.0, 0.0, 0.0, 0.0);
      mrt:
        has_blending = true;
        src_color_blend_factor = zero;
        dst_color_blend_factor = zero;
        color_blend_op = add;
        src_alpha_blend_factor = zero;
        dst_alpha_blend_factor = zero;
        alpha_blend_op = add;

  #hlsl
    void kek(inout float4 c) {
      c = float4(0,0,0,0);
    }
  #end

  #hlsl
    struct VsOutput
    {
      float4 pos: SV_Position;
    };

    VsOutput vs_main()
    {
      VsOutput op;
      op.pos = float4(0,0,0,0);
      return op;
    }
  #end

  #hlsl
    float4 ps_main() : SV_Target
    {
      return float4(0,0,0,0);
    }
  #end

  compile(vs_6_1, vs_main);
  compile(ps_6_1, ps_main);
};
