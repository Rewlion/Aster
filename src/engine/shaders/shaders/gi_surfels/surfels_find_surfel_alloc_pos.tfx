#include <depth.inc.tfx>
#include <frame.inc.tfx>

scope GIBS_FindSurfelsAllocPosScope
{
  reserve:
    descriptor_set(1);
    register(buffer, 0-2);
    register(texture, 0-3);

  #hlsl
  #include "surfel.hlsl"
  #end

  Texture2D gbufferDepth = extern(gbuffer_depth);
  RWTexture2D<uint> surfelsAllocPos = extern(surfelsAllocPos);
  StructuredBuffer<SurfelData> surfelsStorage = extern(surfelsStorage);
  StructuredBuffer<uint> surfelsSpatialStorage = extern(surfelsSpatialStorage);
  RWStructuredBuffer<uint> surfelsLifeTime = extern(surfelsLifeTime);
};

technique GIBS_FindSurfelsAllocPos
{
  support scope FrameScope;
  activate scope GIBS_FindSurfelsAllocPosScope;

  USE_DEPTH_UTILS();
  USE_FRAME_HELPERS();

  #hlsl
  #include "spatial_storage.hlsl"

  [numthreads(8,8,1)]
  void cs_main(uint3 dispatch_thread_id : SV_DispatchThreadID)
  {
    uint2 renderSize;
    gbufferDepth.GetDimensions(renderSize.x, renderSize.y);

    if (any(dispatch_thread_id.xy >= renderSize))
      return;

    uint3 tc = uint3(dispatch_thread_id.xy, 0);
    float depth = gbufferDepth.Load(tc).r;
    if (depth == 0)
      return;

    float3 farPlainPoint = getFarPlanePoint(tc.xy, renderSize);

    float3 worldPos = calcWorldPos(FrameScope.cameraPos, farPlainPoint, depth, FrameScope.zNear_zFar.x, FrameScope.zNear_zFar.y);
    float3 cameraToWorldPos = worldPos - FrameScope.cameraPos;

    ROSpatialStorage st = {surfelsSpatialStorage, FrameScope.nearPlaneDist_farPlaneDist.y};
    bool hasSpace = st.checkFreeSpaceForNewSurfel(worldPos, cameraToWorldPos, surfelsStorage, surfelsLifeTime);

    surfelsAllocPos[tc.xy] = hasSpace ? 1 : 0;
  }
  #end

  compile(cs, cs_main);
};