#include <depth.inc.tfx>

scope GIBS_FindSurfelsAllocPosScope
{
  reserve:
    descriptor_set(1);
    register(buffer, 0-2);
    register(texture, 0-3);

  #hlsl
  #include "surfel.hlsl"
  #end

  Texture2D gbufferDepth = extern(gbuffer_depth);
  RWTexture2D<uint> surfelsAllocPos = extern(surfelsAllocPos);
  StructuredBuffer<SurfelData> surfelsStorage = extern(surfelsStorage);
  StructuredBuffer<uint> surfelsSpatialStorage = extern(surfelsSpatialStorage);
  RWStructuredBuffer<uint> surfelsLifeTime = extern(surfelsLifeTime);
};

technique GIBS_FindSurfelsAllocPos
{
  support scope FrameScope;
  activate scope GIBS_FindSurfelsAllocPosScope;

  USE_DEPTH_UTILS();

  #hlsl
  #include "spatial_storage.hlsl"

  [numthreads(8,8,1)]
  void cs_main(uint3 dispatch_thread_id : SV_DispatchThreadID)
  {
    uint2 renderSize;
    gbufferDepth.GetDimensions(renderSize.x, renderSize.y);

    if (any(dispatch_thread_id.xy >= renderSize))
      return;

    uint3 tc = uint3(dispatch_thread_id.xy, 0);
    float depth = gbufferDepth.Load(tc).r;
    if (depth == 0)
      return;

    float3 leftRight = FrameScope.rtView_WS - FrameScope.ltView_WS;
    float3 topBot = FrameScope.lbView_WS - FrameScope.ltView_WS;

    float2 t = float2(tc.xy) / float2(renderSize - uint2(1, 1));
    float3 farPlainPoint = FrameScope.ltView_WS + leftRight * t.x + topBot * t.y;

    float3 worldPos = calcWorldPos(FrameScope.cameraPos, farPlainPoint, depth, FrameScope.zNear_zFar.x, FrameScope.zNear_zFar.y);
    float3 cameraToWorldPos = worldPos - FrameScope.cameraPos;

    ROSpatialStorage st = {surfelsSpatialStorage, FrameScope.zNear_zFar.x};
    bool hasSpace = st.checkFreeSpaceForNewSurfel(worldPos, cameraToWorldPos, surfelsStorage, surfelsLifeTime);

    surfelsAllocPos[tc.xy] = hasSpace ? 1 : 0;
  }
  #end

  compile(cs, cs_main);
};