#include <atmosphere/sky.inc.tfx>
#include <materials.inc.tfx>
#include <depth.inc.tfx>
#include <frame.inc.tfx>
#include <noise.inc.tfx>
#include <math.inc.tfx>

scope GIBS_TraceIndirectLightScope
{
  reserve:
    descriptor_set(1);
    register(texture, 0-3);
    register(buffer, 0-1);

  Texture2D gbufferNormal = extern(gbuffer_normal);
  Texture2D gbufferDepth = extern(gbuffer_depth);
  RWTexture2D<float4> outputTex = extern(outputTex);
  
  Texture2D skyLUT = extern(skyLUT);

  #hlsl
  #include <gi_surfels/surfel.hlsl>
  #include <gi_surfels/spatial_storage.hlsl>
  #end
  StructuredBuffer<SurfelData> surfelsStorage = extern(surfelsStorage);
  StructuredBuffer<uint> surfelsSpatialStorage = extern(surfelsSpatialStorage);
};

technique GIBS_TraceIndirectLight
{
  support scope FrameScope;
  activate scope GIBS_TraceIndirectLightScope;

  USE_RT();
  USE_NOISE();
  USE_MATH();

  USE_SKY_LUT_SAMPLING();

  USE_MATERIALS_NORMAL_UNPACK();
  USE_DEPTH_UTILS();

  #hlsl
  // #include <gi_surfels/surfel_norm.hlsl>
  // float ellipsoidNorm = calcSurfelEllipsoidNorm(worldPos, surfel);
  // float normalWeight =  max(0, dot(N, surfel.normal));
  // float weight = smoothstep(1.0, 0.0, ellipsoidNorm / surfel.radius) * normalWeight;

  struct FindNeighborSurfelIrradiance
  {
    float3 rayDir;
    float3 intersectPoint;
    float3 surfelIrradiance;
    bool found;

    void init(float3 ray_dir, float3 intersect_point)
    {
      rayDir = ray_dir;
      intersectPoint = intersect_point;
      surfelIrradiance = float3(0,0,0);
      found = false;
    }

    void onSurfel(uint surfel_id)
    {
      SurfelData surfel = surfelsStorage[surfel_id];
      
      float3 dr = (surfel.pos - intersectPoint);
      float dlSq = dot(dr,dr);

      float radius = surfel.radius*1.5;
      bool isOutsideSurfel = dlSq > (radius*radius);

      if (isOutsideSurfel || dot(surfel.normal, -rayDir) < 0)
        return;

      surfelIrradiance = surfel.irradiance;
      found = true;
    }

    bool finish()
    {
      return found;
    }
  };

  [numthreads(8,8,1)]
  void cs_main(uint3 dispatch_thread_id : SV_DispatchThreadID)
  {
    uint2 renderSize;
    outputTex.GetDimensions(renderSize.x, renderSize.y);

    if (any(dispatch_thread_id.xy >= renderSize))
      return;

    uint3 tc = dispatch_thread_id;
    float depth = gbufferDepth.Load(tc).r;

    if (depth == 0.0)
      outputTex[tc.xy] = 0.0.xxxx;

    float3 leftRight = FrameScope.rtView_WS - FrameScope.ltView_WS;
    float3 topBot = FrameScope.lbView_WS - FrameScope.ltView_WS;

    float2 t = float2(tc.xy) / float2(renderSize - uint2(1, 1));
    float3 farPlainPoint = FrameScope.ltView_WS + leftRight * t.x + topBot * t.y;

    float3 N = unpackMaterialNormal(tc);

    RTAccelerationStructure rtas = initRTAS();
    ROSpatialStorage st = {surfelsSpatialStorage, FrameScope.zNear_zFar.x};

    float3 random = random_pcg3d(uint3(dispatch_thread_id.xy, FrameScope.iFrame));
    float phi_l = 2.0 * PI * (random.x);
    float theta_l = PI * random.y;
    float3 rayDir_l = sphericalToDecartian(theta_l, phi_l);

    float3 rayDir = mul(rayDir_l, tsToWs(N));
    float3 rayPos = calcWorldPos(FrameScope.cameraPos, farPlainPoint, depth, FrameScope.zNear_zFar.x, FrameScope.zNear_zFar.y) + rayDir*0.1;

    float3 Ri = 0.xxx;
    TraceResult tRes = rtas.traceRay(rayPos, rayDir);

    if (tRes.t == TRACE_MISS)
    {
      Ri = sampleSkyLUT(rayDir);
    }
    else
    {
      float3 intersectPoint = rayPos + rayDir * tRes.t;
      FindNeighborSurfelIrradiance cb;
      cb.init(rayDir, intersectPoint);

      float3 cameraToWorldPos = intersectPoint - FrameScope.cameraPos;
      st.forEachSurfelInCell(intersectPoint, cameraToWorldPos, cb);

      if (cb.found)
      {
        uint bindlessPackId = tlasInstanceToBindlessPackId[tRes.instanceID] * BINDLESS_MATERIAL_TEX_COUNT;
        uint albedoId = bindlessPackId + BINDLESS_MATERIAL_ALBEDO_TEX;
        uint metalRoughnessId = bindlessPackId + BINDLESS_MATERIAL_METAL_ROUGHNESS_TEX;
        Texture2D albedoTex = bindlessModelTextures[NonUniformResourceIndex(albedoId)];
        Texture2D metalRoughnessTex = bindlessModelTextures[NonUniformResourceIndex(metalRoughnessId)];

        float2 uv = tRes.payload[0].uv * tRes.uvw[0] + tRes.payload[1].uv * tRes.uvw[1] + tRes.payload[2].uv * tRes.uvw[2];
        float3 albedo = albedoTex.SampleLevel(modelSampler, uv, 0).rgb;
        float metalness = metalRoughnessTex.SampleLevel(modelSampler, uv, 0).r;

        Ri = cb.surfelIrradiance * albedo * (1-metalness) / PI;
      }
    }

    outputTex[tc.xy] = float4(Ri, 1.0);
  }
  #end

  compile(cs, cs_main);
};