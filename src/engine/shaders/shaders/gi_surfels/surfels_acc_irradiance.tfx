#include <frame.inc.tfx>
#include <atmosphere/sky.inc.tfx>
#include <math.inc.tfx>
#include <noise.inc.tfx>

scope GIBS_AccSurfelsIrradianceScope
{
  reserve:
    descriptor_set(1);
    register(buffer, 0-1);
    register(texture, 0);
  
  #hlsl
  #include "surfel.hlsl"
  #end

  Texture2D skyLUT = extern(skyLUT);
  RWStructuredBuffer<SurfelData> surfelsStorage = extern(surfelsStorage);
  StructuredBuffer<uint> surfelsSpatialStorage = extern(surfelsSpatialStorage);
};

technique GIBS_AccSurfelsIrradiance
{
  support scope FrameScope;
  activate scope GIBS_AccSurfelsIrradianceScope;

  USE_RT();
  USE_MATH();

  USE_SKY_LUT_SAMPLING();
  USE_NOISE();

  #hlsl
  #include "consts.hlsl"
  #include "spatial_storage.hlsl"
  #include "bindless_material_ids.hlsl"
  #include "surfel_norm.hlsl"

  #include <math.hlsl>

  struct FindNeighborSurfelIrradiance
  {
    float3 rayDir;
    float3 intersectPoint;
    float3 surfelIrradiance;
    bool found;

    void init(float3 ray_dir, float3 intersect_point)
    {
      rayDir = ray_dir;
      intersectPoint = intersect_point;
      surfelIrradiance = float3(0,0,0);
      found = false;
    }

    void onSurfel(uint surfel_id)
    {
      SurfelData surfel = surfelsStorage[surfel_id];
      
      float3 dr = (surfel.pos - intersectPoint);
      float dlSq = dot(dr,dr);
      bool isOutsideSurfel = dlSq > (surfel.radius*surfel.radius);

      if (dot(surfel.normal, -rayDir) <= 0 || isOutsideSurfel)
        return;

      surfelIrradiance = surfel.irradiance;
      found = true;
    }

    bool finish()
    {
      return found;
    }
  };

  struct ShareIrradiance
  {
    uint surfelID;
    SurfelData surfel;

    float3 irradiance;
    float averageWeight;

    void init(SurfelData surfel_data, uint surfel_id)
    {
      surfelID = surfel_id;
      surfel = surfel_data;
      irradiance = float3(0,0,0);
      averageWeight = 0;
    }

    void onSurfel(uint surfel_id)
    {
      if (surfel_id == surfelID)
        return;

      SurfelData neighborSurfel = surfelsStorage[surfel_id];
      
      float ellipsoidNorm = calcSurfelEllipsoidNorm(surfel.pos, neighborSurfel);
      float normalWeight =  max(0, dot(surfel.normal, neighborSurfel.normal));

      float w = ellipsoidNorm;
      w = max(w*w, 0.000001);

      irradiance += neighborSurfel.irradiance * normalWeight / w;
      averageWeight += 1.0/w;
    }

    float3 getResult()
    {
      return irradiance / max(averageWeight, 1);
    }

    bool finish()
    {
      return false;
    }
  };

  float3 accNeighborSurfelsIrradiance(SurfelData surfel, uint surfel_id, ROSpatialStorage spatial_storage, float3 camera_pos)
  {
    ShareIrradiance shareIrradiance;
    shareIrradiance.init(surfel, surfel_id);

    float3 surfelCenter = surfel.pos;
    float3 cameraToSurfelCenter = surfelCenter - camera_pos;

    spatial_storage.forEachSurfelInCell(surfelCenter, cameraToSurfelCenter, shareIrradiance);
    return shareIrradiance.getResult();
  }

  [numthreads(64,1,1)]
  void cs_main(uint3 dispatch_thread_id : SV_DispatchThreadID)
  {
    uint surfelID = dispatch_thread_id.x;
    if (surfelID >= SURFEL_COUNT_TOTAL)
      return;

    RTAccelerationStructure rtas = initRTAS();
    ROSpatialStorage st = {surfelsSpatialStorage, FrameScope.zNear_zFar.x};

    SurfelData surfel = surfelsStorage[surfelID];
    
    float3 random = random_pcg3d(uint3(surfelID,0, FrameScope.iFrame));
    float dirPhi_ls = 2.0 * PI * random.x;
    float dirTheta_ls = PI * random.y;
    float3 dir_ls = sphericalToDecartian(dirTheta_ls, dirPhi_ls);

    float3 rayDir = mul(dir_ls, tsToWs(surfel.normal));
    float3 rayPos = surfel.pos + surfel.normal * 0.1;

    TraceResult tRes = rtas.traceRay(rayPos, rayDir);
    
    float3 L = float3(0,0,0);
    if (tRes.t == TRACE_MISS)
      L = sampleSkyLUT(rayDir);
    else
    {
      float3 intersectPoint = rayPos + rayDir * tRes.t;
      FindNeighborSurfelIrradiance cb;
      cb.init(surfel.normal,intersectPoint);
      
      float3 cameraToWorldPos = intersectPoint - FrameScope.cameraPos;
      st.forEachSurfelInCell(intersectPoint, cameraToWorldPos, cb);

      if (cb.found)
      {
        uint bindlessPackId = tlasInstanceToBindlessPackId[tRes.instanceID] * BINDLESS_MATERIAL_TEX_COUNT;
        uint albedoId = bindlessPackId + BINDLESS_MATERIAL_ALBEDO_TEX;
        uint metalRoughnessId = bindlessPackId + BINDLESS_MATERIAL_METAL_ROUGHNESS_TEX;
        Texture2D albedoTex = bindlessModelTextures[NonUniformResourceIndex(albedoId)];
        Texture2D metalRoughnessTex = bindlessModelTextures[NonUniformResourceIndex(metalRoughnessId)];

        float2 uv = tRes.payload[0].uv * tRes.uvw[0] + tRes.payload[1].uv * tRes.uvw[1] + tRes.payload[2].uv * tRes.uvw[2];
        float3 albedo = albedoTex.SampleLevel(modelSampler, uv, 0).rgb;
        float metalness = metalRoughnessTex.SampleLevel(modelSampler, uv, 0).r;

        L = cb.surfelIrradiance * albedo * (1-metalness);
      }
    }
    
    float3 neighborsIrradiance = accNeighborSurfelsIrradiance(surfel, surfelID, st, FrameScope.cameraPos);

    uint n = surfel.irradianceHistory;
    float3 irradiance = lerp(surfel.irradiance, L, 1.0 / (n+1));
    irradiance = lerp(irradiance, neighborsIrradiance, 1.0 / (n+2));

    surfelsStorage[surfelID].irradiance = irradiance;
    surfelsStorage[surfelID].irradianceHistory = n+2;
  }
  #end

  compile(cs, cs_main);
};