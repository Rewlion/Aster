#include <frame.inc.tfx>
#include <atmosphere/sky.inc.tfx>
#include <atmosphere/sph.inc.tfx>
#include <atmosphere/atmosphere.inc.tfx>
#include <math.inc.tfx>
#include <noise.inc.tfx>
#include <color_spaces.inc.tfx>
#include <materials.inc.tfx>

scope GIBS_AccSunIrradianceScope
{
  reserve:
    descriptor_set(2);
    register(texture, 0);
    register(buffer, 0-3);
  
  #hlsl
  #include "surfel.hlsl"
  #end

  StructuredBuffer<uint> surfelsLifeTime = extern(surfelsLifeTime);
  RWStructuredBuffer<SurfelData> surfelsStorage = extern(surfelsStorage);
  StructuredBuffer<uint> surfelsSpatialStorage = extern(surfelsSpatialStorage);

  StructuredBuffer<float3> atmParamsBuffer = extern(atmParamsBuffer);
  Texture2D skyLUT = extern(skyLUT);
};

technique GIBS_AccSunIrradiance
{
  support scope FrameScope;
  activate scope GIBS_AccSunIrradianceScope;

  USE_RT();
  USE_MATH();

  #hlsl
  #include <atmosphere/sph.hlsl>
  #end
  USE_ATM_SPH();
  USE_ATMOSPHERE_PARAMS();

  #hlsl
  #include "consts.hlsl"
  #include "spatial_storage.hlsl"
  #include "multiscale_mean_estimator.hlsl"

  #include <math.hlsl>

  [numthreads(64,1,1)]
  void cs_main(uint3 dispatch_thread_id : SV_DispatchThreadID)
  {
    uint surfelID = dispatch_thread_id.x;
    if (surfelID >= SURFEL_COUNT_TOTAL)
      return;

    Lifetime lifetime = {surfelsLifeTime[surfelID]};
    if (!lifetime.isAlive())
      return;

    RTAccelerationStructure rtas = initRTAS();
    ROSpatialStorage st = {surfelsSpatialStorage, FrameScope.zNear_zFar.x};

    SurfelData surfel = surfelsStorage[surfelID];
    if (surfel.rayBudget == 0)
      return;

    float3 rayPos = surfel.pos + surfel.normal * 0.1;
    float3 lightDir = getAtmSunDir();

    TraceResult tRes = rtas.traceRay(rayPos, lightDir);
    if (tRes.t == TRACE_MISS)
    {
      float3 sunL = getSunL();
      float NoL = dot(surfel.normal, lightDir);
      MultiscaleMeanEstimator(sunL * NoL, surfel.estimatorData);
    }

    surfelsStorage[surfelID].estimatorData = surfel.estimatorData;
  }
  #end

  compile(cs, cs_main);
};

scope GIBS_AccSurfelsIrradianceScope
{
  reserve:
    descriptor_set(2);
    register(buffer, 0-3);
    register(texture, 0-1);
  
  #hlsl
  #include "surfel.hlsl"
  #end

  Texture2D skyLUT = extern(skyLUT);
  StructuredBuffer<uint> surfelsLifeTime = extern(surfelsLifeTime);
  RWTexture2D<float2> rayguidingMap = extern(rayguidingMap);
  RWStructuredBuffer<SurfelData> surfelsStorage = extern(surfelsStorage);
  StructuredBuffer<uint> surfelsSpatialStorage = extern(surfelsSpatialStorage);
  StructuredBuffer<float3> atmParamsBuffer = extern(atmParamsBuffer);
};

technique GIBS_AccSurfelsIrradiance
{
  support scope FrameScope;
  activate scope GIBS_AccSurfelsIrradianceScope;

  USE_RT();
  USE_MATH();

  USE_SKY_LUT_SAMPLING();
  USE_NOISE();
  USE_COLOR_SPACES();

  #hlsl
  #include <atmosphere/sph.hlsl>
  #end
  USE_ATM_SPH();
  USE_ATMOSPHERE_PARAMS();

  #hlsl
  #include "consts.hlsl"
  #include "spatial_storage.hlsl"
  #include "bindless_material_ids.hlsl"
  #include "surfel_norm.hlsl"
  #include "multiscale_mean_estimator.hlsl"
  #include "rayguiding.hlsl"

  #include <math.hlsl>

  struct FindNeighborSurfelIrradiance
  {
    float3 rayDir;
    float3 intersectPoint;
    float3 surfelIrradiance;
    bool found;

    void init(float3 ray_dir, float3 intersect_point)
    {
      rayDir = ray_dir;
      intersectPoint = intersect_point;
      surfelIrradiance = float3(0,0,0);
      found = false;
    }

    void onSurfel(uint surfel_id)
    {
      SurfelData surfel = surfelsStorage[surfel_id];
      
      float3 dr = (surfel.pos - intersectPoint);
      float dlSq = dot(dr,dr);
      bool isOutsideSurfel = dlSq > (surfel.radius*surfel.radius);

      if (isOutsideSurfel || dot(surfel.normal, -rayDir) < 0)
        return;

      surfelIrradiance = surfel.irradiance;
      found = true;
    }

    bool finish()
    {
      return found;
    }
  };

  float3 traceSun(float3 ray_pos, float3 normal, RTAccelerationStructure rtas)
  {
    float3 lightDir = getAtmSunDir();
    TraceResult tRes = rtas.traceRay(ray_pos + normal * 0.1, lightDir);

    if (tRes.t == TRACE_MISS)
    {
      float3 sunL = getSunL();
      float NoL = saturate(dot(normal, lightDir));
      return sunL * NoL;
    }

    return 0.xxx;
  }

  float3 traceHemisphereEnvironment(float3 ray_pos, float3 ray_dir, ROSpatialStorage st, RTAccelerationStructure rtas, out bool useful_ray)
  {
    TraceResult tRes = rtas.traceRay(ray_pos, ray_dir);
    
    useful_ray = false;
    float3 Ri = float3(0,0,0);

    if (tRes.t == TRACE_MISS)
    {
      Ri = sampleSkyLUT(ray_dir);
      useful_ray = true;
    }
    else
    {
      uint bindlessPackId = tlasInstanceToBindlessPackId[tRes.instanceID] * BINDLESS_MATERIAL_TEX_COUNT;
      uint albedoId = bindlessPackId + BINDLESS_MATERIAL_ALBEDO_TEX;
      uint normalId = bindlessPackId + BINDLESS_MATERIAL_NORMAL_TEX;
      uint metalRoughnessId = bindlessPackId + BINDLESS_MATERIAL_METAL_ROUGHNESS_TEX;
      Texture2D albedoTex = bindlessModelTextures[NonUniformResourceIndex(albedoId)];
      Texture2D metalRoughnessTex = bindlessModelTextures[NonUniformResourceIndex(metalRoughnessId)];

      float2 uv = tRes.payload[0].uv * tRes.uvw[0] + tRes.payload[1].uv * tRes.uvw[1] + tRes.payload[2].uv * tRes.uvw[2];
      float3 albedo = albedoTex.SampleLevel(modelSampler, uv, 0).rgb;
      float3 normal = mul(tRes.objectToWorldTm, float4(tRes.normal_os, 0.0)).rgb;
      float metalness = metalRoughnessTex.SampleLevel(modelSampler, uv, 0).r;

      float3 irradiance = 0.xxx;
      float3 intersectPoint = ray_pos + ray_dir * tRes.t;

      irradiance += traceSun(intersectPoint, normal, rtas);

      FindNeighborSurfelIrradiance cb;
      cb.init(ray_dir,intersectPoint);
      
      float3 cameraToWorldPos = intersectPoint - FrameScope.cameraPos;
      st.forEachSurfelInCell(intersectPoint, cameraToWorldPos, cb);

      if (cb.found)
        irradiance += cb.surfelIrradiance;
      
      Ri = irradiance * albedo * (1-metalness) / PI;
      useful_ray = all(irradiance != 0.xxx);
    }
    
    return Ri;
  }

  uint rayguidedSampleEnvironment(RayGuiding rayguiding, uint rayBudget, float3 ray_pos, float3 surfel_normal, uint surfel_id,
                                  ROSpatialStorage st, RTAccelerationStructure rtas, inout MultiscaleMeanEstimatorData estimator_data)
  { 
    float3 irradiance = 0.xxx;

    uint usefulRays = 0;

    for (uint i = 0; i < rayBudget; ++i)
    {
      float3 random = random_pcg3d(uint3(surfel_id % 36, i, FrameScope.iFrame));
      
      uint2 rayGuidingFeedbackTexel;
      float rayGuidingProbability;
      float3 dir_ls = rayguiding.guide(random, rayGuidingFeedbackTexel, rayGuidingProbability);
  
      float3 rayDir = mul(dir_ls, tsToWs(surfel_normal));
      float NoWi = saturate(dot(rayDir, surfel_normal));

      float incomingLuminance;
      bool isUsefulRay;
      float3 Ri = traceHemisphereEnvironment(ray_pos, rayDir, st, rtas, isUsefulRay);

      irradiance += Ri * NoWi / rayGuidingProbability;
      float luminance = luminance_ub(Ri * NoWi);

      if (isUsefulRay)
      {
        rayguiding.feedbackLuminance(rayGuidingFeedbackTexel, luminance);
        usefulRays += 1;
      }
    }

    uint processedSamples = rayBudget;

    irradiance = irradiance / max(usefulRays, 1);
    MultiscaleMeanEstimator(irradiance, estimator_data);

    return processedSamples;
  }

  [numthreads(64,1,1)]
  void cs_main(uint3 dispatch_thread_id : SV_DispatchThreadID)
  {
    uint surfelID = dispatch_thread_id.x;
    if (surfelID >= SURFEL_COUNT_TOTAL)
      return;

    Lifetime lifetime = {surfelsLifeTime[surfelID]};
    if (!lifetime.isAlive())
      return;

    RTAccelerationStructure rtas = initRTAS();
    ROSpatialStorage st = {surfelsSpatialStorage, FrameScope.zNear_zFar.x};

    SurfelData surfel = surfelsStorage[surfelID];
    if (surfel.rayBudget == 0)
      return;

    float3 rayPos = surfel.pos + surfel.normal * 0.2;
    
    RayGuiding rayguiding;
    rayguiding.init(rayguidingMap, surfel.rayguidingPmfScale, surfelID);
    uint processedSamples = rayguidedSampleEnvironment(rayguiding, surfel.rayBudget, rayPos, surfel.normal, surfelID, st, rtas, surfel.estimatorData);

    surfelsStorage[surfelID].estimatorData = surfel.estimatorData;
    surfelsStorage[surfelID].rayguidingProcessedSamples = surfel.rayguidingProcessedSamples + processedSamples;
  }
  #end

  compile(cs, cs_main);
};