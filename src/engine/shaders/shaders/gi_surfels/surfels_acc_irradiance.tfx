#include <frame.inc.tfx>
#include <atmosphere/sky.inc.tfx>
#include <atmosphere/sph.inc.tfx>
#include <atmosphere/atmosphere.inc.tfx>
#include <math.inc.tfx>
#include <noise.inc.tfx>
#include <color_spaces.inc.tfx>

scope GIBS_AccSurfelsIrradianceScope
{
  reserve:
    descriptor_set(2);
    register(buffer, 0-3);
    register(texture, 0-1);
  
  #hlsl
  #include "surfel.hlsl"
  #end

  Texture2D skyLUT = extern(skyLUT);
  StructuredBuffer<uint> surfelsLifeTime = extern(surfelsLifeTime);
  RWTexture2D<float2> rayguidingMap = extern(rayguidingMap);
  RWStructuredBuffer<SurfelData> surfelsStorage = extern(surfelsStorage);
  StructuredBuffer<uint> surfelsSpatialStorage = extern(surfelsSpatialStorage);
  StructuredBuffer<float3> atmParamsBuffer = extern(atmParamsBuffer);
};

technique GIBS_AccSurfelsIrradiance
{
  support scope FrameScope;
  activate scope GIBS_AccSurfelsIrradianceScope;

  USE_RT();
  USE_MATH();

  #hlsl
  #include <atmosphere/sph.hlsl>
  #end

  USE_ATM_SPH();
  USE_ATMOSPHERE_PARAMS();
  USE_SKY_LUT_SAMPLING();
  USE_NOISE();
  USE_COLOR_SPACES();

  #hlsl
  #include "consts.hlsl"
  #include "spatial_storage.hlsl"
  #include "bindless_material_ids.hlsl"
  #include "surfel_norm.hlsl"
  #include "multiscale_mean_estimator.hlsl"
  #include "rayguiding.hlsl"

  #include <math.hlsl>

  struct FindNeighborSurfelIrradiance
  {
    float3 rayDir;
    float3 intersectPoint;
    float3 surfelIrradiance;
    bool found;

    void init(float3 ray_dir, float3 intersect_point)
    {
      rayDir = ray_dir;
      intersectPoint = intersect_point;
      surfelIrradiance = float3(0,0,0);
      found = false;
    }

    void onSurfel(uint surfel_id)
    {
      SurfelData surfel = surfelsStorage[surfel_id];
      
      float3 dr = (surfel.pos - intersectPoint);
      float dlSq = dot(dr,dr);
      bool isOutsideSurfel = dlSq > (surfel.radius*surfel.radius);

      if (isOutsideSurfel || dot(surfel.normal, -rayDir) < 0)
        return;

      surfelIrradiance = surfel.irradiance;
      found = true;
    }

    bool finish()
    {
      return found;
    }
  };

  struct ShareIrradiance
  {
    uint surfelID;
    SurfelData surfel;

    float3 irradiance;
    float averageWeight;

    void init(SurfelData surfel_data, uint surfel_id)
    {
      surfelID = surfel_id;
      surfel = surfel_data;
      irradiance = float3(0,0,0);
      averageWeight = 0;
    }

    void onSurfel(uint surfel_id)
    {
      if (surfel_id == surfelID)
        return;

      SurfelData neighborSurfel = surfelsStorage[surfel_id];
      
      float ellipsoidNorm = calcSurfelEllipsoidNorm(surfel.pos, neighborSurfel);
      float normalWeight =  max(0, dot(surfel.normal, neighborSurfel.normal));

      float w = ellipsoidNorm;
      w = max(w*w, 0.000001);

      irradiance += neighborSurfel.irradiance * normalWeight / w;
      averageWeight += 1.0/w;
    }

    float3 getResult()
    {
      return irradiance / max(averageWeight, 0.001);
    }

    bool finish()
    {
      return false;
    }
  };

  float3 accNeighborSurfelsIrradiance(SurfelData surfel, uint surfel_id, ROSpatialStorage spatial_storage, float3 camera_pos)
  {
    ShareIrradiance shareIrradiance;
    shareIrradiance.init(surfel, surfel_id);

    float3 surfelCenter = surfel.pos;
    float3 cameraToSurfelCenter = surfelCenter - camera_pos;

    spatial_storage.forEachSurfelInCell(surfelCenter, cameraToSurfelCenter, shareIrradiance);
    return shareIrradiance.getResult();
  }

  void sampleSunDiskRadiance(float3 ray_pos, inout SurfelData surfel, RTAccelerationStructure rtas)
  {
    float3 lightDir = getAtmSunDir();
    TraceResult tRes = rtas.traceRay(ray_pos, lightDir);
    if (tRes.t == TRACE_MISS)
    {
      float3 sunL = getSunL();
      float NoL = dot(surfel.normal, lightDir);
      MultiscaleMeanEstimator(sunL * NoL, surfel.estimatorData);
    }
  }

  float3 traceHemisphereEnvironment(float3 ray_pos, float3 ray_dir, ROSpatialStorage st, RTAccelerationStructure rtas)
  {
    TraceResult tRes = rtas.traceRay(ray_pos, ray_dir);
    
    float3 Ri = float3(0,0,0);
    if (tRes.t == TRACE_MISS)
      Ri = sampleSkyLUT(ray_dir);
    else
    {
      float3 intersectPoint = ray_pos + ray_dir * tRes.t;
      FindNeighborSurfelIrradiance cb;
      cb.init(ray_dir,intersectPoint);
      
      float3 cameraToWorldPos = intersectPoint - FrameScope.cameraPos;
      st.forEachSurfelInCell(intersectPoint, cameraToWorldPos, cb);

      if (cb.found)
      {
        uint bindlessPackId = tlasInstanceToBindlessPackId[tRes.instanceID] * BINDLESS_MATERIAL_TEX_COUNT;
        uint albedoId = bindlessPackId + BINDLESS_MATERIAL_ALBEDO_TEX;
        uint metalRoughnessId = bindlessPackId + BINDLESS_MATERIAL_METAL_ROUGHNESS_TEX;
        Texture2D albedoTex = bindlessModelTextures[NonUniformResourceIndex(albedoId)];
        Texture2D metalRoughnessTex = bindlessModelTextures[NonUniformResourceIndex(metalRoughnessId)];

        float2 uv = tRes.payload[0].uv * tRes.uvw[0] + tRes.payload[1].uv * tRes.uvw[1] + tRes.payload[2].uv * tRes.uvw[2];
        float3 albedo = albedoTex.SampleLevel(modelSampler, uv, 0).rgb;
        float metalness = metalRoughnessTex.SampleLevel(modelSampler, uv, 0).r;

        Ri = cb.surfelIrradiance * albedo * (1-metalness) / PI;
      }
    }
    
    return Ri;
  }

  uint rayguidedSampleEnvironment(RayGuiding rayguiding, float3 ray_pos, float3 surfel_normal, uint surfel_id,
                                  ROSpatialStorage st, RTAccelerationStructure rtas, inout MultiscaleMeanEstimatorData estimator_data)
  { 
    const uint maxRayCounts = 36;

    float3 irradiance = 0.xxx;

    for (uint i = 0; i < maxRayCounts; ++i)
    {
      float3 random = random_pcg3d(uint3(surfel_id, i, FrameScope.iFrame));
      
      uint2 rayGuidingFeedbackTexel;
      float rayGuidingProbability;
      float3 dir_ls = rayguiding.guide(random, rayGuidingFeedbackTexel, rayGuidingProbability);
  
      float3 rayDir = mul(dir_ls, tsToWs(surfel_normal));
      float NoWi = dot(rayDir, surfel_normal);

      float incomingLuminance;
      float3 Ri = traceHemisphereEnvironment(ray_pos, rayDir, st, rtas);

      irradiance += Ri * NoWi / rayGuidingProbability;
      float luminance = luminance_ub(Ri * NoWi);

      rayguiding.feedbackLuminance(rayGuidingFeedbackTexel, luminance);
    }

    uint processedSamples = maxRayCounts;

    irradiance = irradiance / processedSamples;
    MultiscaleMeanEstimator(irradiance, estimator_data);

    return processedSamples;
  }

  [numthreads(64,1,1)]
  void cs_main(uint3 dispatch_thread_id : SV_DispatchThreadID)
  {
    uint surfelID = dispatch_thread_id.x;
    if (surfelID >= SURFEL_COUNT_TOTAL)
      return;

    Lifetime lifetime = {surfelsLifeTime[surfelID]};
    if (!lifetime.isAlive())
      return;

    RTAccelerationStructure rtas = initRTAS();
    ROSpatialStorage st = {surfelsSpatialStorage, FrameScope.zNear_zFar.x};

    SurfelData surfel = surfelsStorage[surfelID];
    float3 rayPos = surfel.pos + surfel.normal * 0.1;
    
    sampleSunDiskRadiance(rayPos, surfel, rtas);

    RayGuiding rayguiding;
    rayguiding.init(rayguidingMap, surfel.rayguidingPmfScale, surfelID);
    uint processedSamples = rayguidedSampleEnvironment(rayguiding, rayPos, surfel.normal, surfelID, st, rtas, surfel.estimatorData);

    surfelsStorage[surfelID].estimatorData = surfel.estimatorData;
    surfelsStorage[surfelID].rayguidingProcessedSamples = surfel.rayguidingProcessedSamples + processedSamples;
  }
  #end

  compile(cs, cs_main);
};