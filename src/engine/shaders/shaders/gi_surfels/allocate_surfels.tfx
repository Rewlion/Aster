#include <frame.inc.tfx>
#include <depth.inc.tfx>
#include <materials.inc.tfx>

scope GIBS_AllocateSurfelsScope
{
  reserve:
    descriptor_set(1);
    register(buffer, 0-7);
    register(texture, 0-5);

  RWTexture2D<float4> dbgOutput = extern(dbgTex);
  Texture2D gbufferDepth = extern(gbuffer_depth);
  Texture2D gbufferNormal = extern(gbuffer_normal);
  
  #hlsl
  #include "meta.hlsl"
  #include "surfel.hlsl"
  #end
  
  Texture2D<uint> surfelsAllocPos = extern(surfelsAllocPos);
  RWStructuredBuffer<uint> surfelsLifeTime = extern(surfelsLifeTime);
  RWStructuredBuffer<SurfelData> surfelsStorage = extern(surfelsStorage);
  RWStructuredBuffer<uint> surfelsPool = extern(surfelsPool);
  RWStructuredBuffer<uint> surfelsAllocLocks = extern(surfelsAllocLocks);
  RWStructuredBuffer<SurfelsMeta> surfelsMeta = extern(surfelsMeta);
  RWTexture2D<float2> rayguidingMap = extern(rayguidingMap);
};

technique GIBS_AllocateSurfels
{
  activate scope FrameScope;
  activate scope GIBS_AllocateSurfelsScope;

  USE_DEPTH_UTILS();
  USE_MATERIALS_NORMAL_UNPACK();
  USE_FRAME_HELPERS();

  #hlsl
  #include "lifetime.hlsl"
  #include "spatial_hash.hlsl"
  #include "surfel_pool.hlsl"
  #include "rayguiding.hlsl"

  struct SpatialLock
  {
    bool tryLock(int3 spatial_id, int cascade)
    {
      uint baseAddr = cascade * CELLS_PER_CASCADE;
      uint id = calcSpatial1DIndex(spatial_id);
      uint addr = baseAddr + id;

      uint isLocked;
      InterlockedCompareExchange(locks[addr], 0, 1, isLocked);
      
      return isLocked == 0;
    }

    RWStructuredBuffer<uint> locks;
  };

  [numthreads(8,8,1)]
  void cs_main(uint3 dispatch_thread_id : SV_DispatchThreadID)
  {
    uint2 renderSize;
    dbgOutput.GetDimensions(renderSize.x, renderSize.y);

    if (any(dispatch_thread_id.xy >= renderSize))
      return;

    uint3 tc = uint3(dispatch_thread_id.xy, 0);
    float depth = gbufferDepth.Load(tc).r;
    if (depth == 0)
      return;

    if (surfelsAllocPos.Load(tc) == 0)
      return;

    float3 N = unpackMaterialNormal(tc);

    float3 leftRight = FrameScope.rtView_WS - FrameScope.ltView_WS;
    float3 topBot = FrameScope.lbView_WS - FrameScope.ltView_WS;

    float2 t = float2(tc.xy) / float2(renderSize - uint2(1, 1));
    float3 farPlainPoint = FrameScope.ltView_WS + leftRight * t.x + topBot * t.y;

    float3 worldPos = calcWorldPosITM(tc.xy, renderSize, depth);//calcWorldPos(FrameScope.cameraPos, farPlainPoint, depth, FrameScope.zNear_zFar.x, FrameScope.zNear_zFar.y);
    float3 cameraToWorldPos = worldPos - FrameScope.cameraPos;
    
    SpatialInfo spatialInfo = calcSpatialInfo(cameraToWorldPos, FrameScope.nearPlaneDist_farPlaneDist.y);

    SpatialLock spatialLocks = {surfelsAllocLocks};

    [BRANCH]
    if (spatialLocks.tryLock(spatialInfo.id, spatialInfo.cascade))
    {
      SurfelsPool pool = { surfelsMeta, surfelsPool};

      uint surfelId = pool.acquireFreeSurfelId();
      if (surfelId != NO_AVAILABLE_SURFEL)
      {
        float r = calcSurfelRadius(spatialInfo.cellSize);
        SurfelData surfel;
        surfel.init(worldPos, r, N);

        initializeRayguidingMap(rayguidingMap, surfelId);

        surfelsStorage[surfelId] = surfel;
        
        Lifetime lifetime = {0};
        lifetime.markAllocated();
        surfelsLifeTime[surfelId] = lifetime.data;
      }
    }

    float3 colors[1+6] = {
      float3(0.8,0.8,0.8),
      float3(0.8, 0, 0),
      float3(0.4, 0.1, 0.1),
      float3(0, 0.8, 0),
      float3(0.1, 0.4, 0.1),
      float3(0, 0, 0.8),
      float3(0.1, 0.1, 0.4)
    };

    int3 dId = (spatialInfo.id % 2);
    //float m = all(dId == int3(0,0,0)) || all(dId == int3(1,1,1)) ? 0.5 : 1.0;
    //float m = all(dId.xy == int2(0,0)) || all(dId.xy == int2(1,1)) ? 0.5 : 1.0;
    float m = all(dId == int3(1,1,1)) ||  all(dId == int3(0,0,1)) ||  all(dId == int3(0,1,0)) ||  all(dId == int3(1,0,0)) ? 1.0 : 0.5;
    //float m = dId.x == 0 ? 1.0 : 0.5;
    dbgOutput[tc.xy] = float4(colors[spatialInfo.cascade % 7] * m, 1.0);
  }
  #end

  compile(cs, cs_main);
};