#include <frame.inc.tfx>

scope GIBS_SpatialStorageBinning
{
  reserve:
    descriptor_set(1);
    register(buffer, 0-6);

  #hlsl
  #include "surfel.hlsl"
  #include "meta.hlsl"
  #include <intersection_structs.hlsl>
  #end
  RWStructuredBuffer<uint> surfelsLifeTime = extern(surfelsLifeTime);
  StructuredBuffer<SurfelData> surfelsStorage = extern(surfelsStorage);
  RWStructuredBuffer<uint> surfelsSpatialStorage = extern(surfelsSpatialStorage);
  StructuredBuffer<AABB> nonlinearAABBs = extern(gibsNonlinearAABBs);

  RWStructuredBuffer<uint> surfelsPool = extern(surfelsPool);
  RWStructuredBuffer<SurfelsMeta> surfelsMeta = extern(surfelsMeta);
};

technique GIBS_SpatialStorageBinning
{
  support scope FrameScope;
  activate scope GIBS_SpatialStorageBinning;

  #hlsl
  #include "lifetime.hlsl"
  #include "spatial_storage.hlsl"
  #include "surfel_pool.hlsl"

  [numthreads(64,1,1)]
  void cs_main(uint3 dispatch_thread_id : SV_DispatchThreadID)
  {
    uint surfelId = dispatch_thread_id.x;
    if (surfelId >= SURFEL_COUNT_TOTAL)
      return;

    Lifetime lifetime = {surfelsLifeTime[surfelId]};
    if (!lifetime.isAlive())
      return;

    SurfelData surfel = surfelsStorage[surfelId];
    SpatialStorage st = {surfelsSpatialStorage, FrameScope.nearPlaneDist_farPlaneDist.y};
    bool surfelInserted = st.insertSurfel(surfel, surfelId, FrameScope.cameraPos, nonlinearAABBs);

    if (!surfelInserted)
    {
      lifetime.markPendingRecycle();
      surfelsLifeTime[surfelId] = lifetime.data;
    }
  }
  #end

  compile(cs, cs_main);
};
