#include <frame.inc.tfx>

scope GIBS_TransformSurfelsScope
{
  reserve:
    descriptor_set(1);
    register(buffer, 0-1);

  #hlsl
  #include "surfel.hlsl"
  #end

  StructuredBuffer<uint> surfelsLifeTime = extern(surfelsLifeTime);
  RWStructuredBuffer<SurfelData> surfelsStorage = extern(surfelsStorage);
};


technique GIBS_TransformSurfels
{
  support scope FrameScope;
  activate scope GIBS_TransformSurfelsScope;

  #hlsl
  #include "consts.hlsl"
  #include "lifetime.hlsl"
  #include "spatial_hash.hlsl"

  [numthreads(64,1,1)]
  void cs_main(uint3 dispatch_thread_id : SV_DispatchThreadID)
  {
    uint id = dispatch_thread_id.x;

    if (id >= SURFEL_COUNT_TOTAL)
      return;

    uint lifetime = surfelsLifeTime[id];
    if (id == SURFEL_STATE_UNUSED)
      return;

    SurfelData surfel = surfelsStorage[id];
    float3 cameraToWpos = surfel.pos - FrameScope.cameraPos;

    float cellSize;
    if (isLinearTransform(cameraToWpos))
    {
      cellSize = CELL_SIZE;
    }
    else
    {
      PointInCascade p = transformFromCameraWorldSpaceToCascadeSpace(cameraToWpos);
      cellSize = calcNonLinearCellSizeFromCascadeZ(p.pos.z);
    }
    float newRadius = calcSurfelRadius(cellSize);

    if (newRadius != surfel.radius)
      surfelsStorage[id].radius = newRadius;
  }
  #end

  compile(cs, cs_main);
};