#include <frame.inc.tfx>

scope GIBS_TransformSurfelsScope
{
  reserve:
    descriptor_set(1);
    register(buffer, 0-2);
    register(texture, 0);

  #hlsl
  #include "surfel.hlsl"
  #end

  StructuredBuffer<uint> surfelsLifeTime = extern(surfelsLifeTime);
  RWStructuredBuffer<SurfelData> surfelsStorage = extern(surfelsStorage);
  RWTexture2D<float2> rayguidingMap = extern(rayguidingMap);
  RWStructuredBuffer<int> surfelsRayBudget = extern(surfelsRayBudget);
};


technique GIBS_TransformSurfels
{
  support scope FrameScope;
  activate scope GIBS_TransformSurfelsScope;

  #hlsl
  #include "consts.hlsl"
  #include "lifetime.hlsl"
  #include "rayguiding.hlsl"
  #include "spatial_hash.hlsl"

  [numthreads(64,1,1)]
  void cs_main(uint3 dispatch_thread_id : SV_DispatchThreadID)
  {
    uint id = dispatch_thread_id.x;

    if (id >= SURFEL_COUNT_TOTAL)
      return;

    Lifetime lifetime = {surfelsLifeTime[id]};
    if (!lifetime.isAlive())
      return;

    SurfelData surfel = surfelsStorage[id];
    float3 cameraToWpos = surfel.pos - FrameScope.cameraPos;

    float cellSize;
    if (isLinearTransform(cameraToWpos))
    {
      cellSize = CELL_SIZE;
    }
    else
    {
      PointInCascade p = transformFromCameraWorldSpaceToCascadeSpace(cameraToWpos);
      cellSize = calcNonLinearCellSizeFromCascadeZ(p.pos.z);
    }
    float newRadius = calcSurfelRadius(cellSize);

    if (newRadius != surfel.radius)
      surfelsStorage[id].radius = newRadius;

    surfelsStorage[id].irradiance = surfel.estimatorData.mean;

    int rayBudget;
    int rayRequest = lerp(1, SURFEL_MAX_RAYS, surfel.estimatorData.inconsistency);
    rayRequest = clamp(rayRequest, 1, SURFEL_MAX_RAYS);
    InterlockedAdd(surfelsRayBudget[0], -rayRequest, rayBudget);
    surfelsStorage[id].rayBudget = rayBudget < 0 ? 0 : rayRequest;

    [BRANCH]
    if (surfelsStorage[id].rayguidingProcessedSamples >= RAYGUIDE_MAX_SAMPLES_PER_ITERATION)
    {
      surfelsStorage[id].rayguidingPmfScale = renormalizeRayguidingMap(rayguidingMap, id);
      surfelsStorage[id].rayguidingProcessedSamples = 0;
    }
  }
  #end

  compile(cs, cs_main);
};