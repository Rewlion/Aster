#include <materials.inc.tfx>
#include <color_spaces.inc.tfx>

scope GIBS_IndirectLightSpatialFilterScope
{
  reserve:
    descriptor_set(1);
    register(texture, 0-4);
    register(buffer, 0);

  uint stepSize = extern(stepSize);

  Texture2D filterInput = extern(filterInput);
  RWTexture2D<float4> filterOutput = extern(filterOutput);

  Texture2D variance = extern(variance);
  Texture2D gbufferNormal = extern(gbuffer_normal);
  Texture2D gbufferDepth = extern(gbuffer_depth);
};

technique GIBS_IndirectLightSpatialFilter
{
  activate scope GIBS_IndirectLightSpatialFilterScope;

  USE_MATERIALS_NORMAL_UNPACK();
  USE_COLOR_SPACES();

  #hlsl

  float SVGF_normalWeight(float3 normal, float3 sample_normal)
  {
    int sigma = 128;
    return pow(max(0, dot(normal, sample_normal) ), sigma);
  }

  float SVGF_depthWeight(float depth, float sample_depth, float2 depth_grad, float2 offset)
  {
    int sigma = 1;
    float eps = 0.005;

    return exp( - ( abs(sample_depth - depth) ) / (sigma * abs(dot(depth_grad, offset)) + eps) );
  }

  float SVGF_luminanceWeight(float luminance, float sample_luminance, float Var)
  {
    float eps = 0.005;
    float sigma = 4.0;
    return exp(- (sample_luminance - luminance) / (sigma * Var + eps));
  }

  float2 calcDepthGrad(float depth, uint3 tc, uint2 render_size)
  {
    int3 rightTC = int3(clamp(int2(tc.xy) + int2(1,0), 0.xx, render_size - 1.xx), 0);
    int3 topTC   = int3(clamp(int2(tc.xy) + int2(0,1), 0.xx, render_size - 1.xx), 0);

    float rightDepth = gbufferDepth.Load(rightTC).r;
    float topDepth = gbufferDepth.Load(topTC).r;

    return float2(rightDepth - depth, topDepth - depth);
  }

  [numthreads(8,8,1)]
  void cs_main(uint3 dispatch_thread_id : SV_DispatchThreadID)
  {
    uint2 renderSize;
    filterInput.GetDimensions(renderSize.x, renderSize.y);

    uint3 tc = uint3(dispatch_thread_id.xy, 0);
    if (any(tc.xy > renderSize))
      return;

    float depth = gbufferDepth.Load(tc).r;
    if (depth == 0.0)
      return;

    float2 depthGrad = calcDepthGrad(depth, tc, renderSize);
    float3 normal = unpackMaterialNormal(tc);
    float3 color = filterInput.Load(tc).rgb;
    float pLuminance = luminance(color);
    float Var = variance.Load(tc).r;

    float h[3] = {3.0/8.0, 1.0/4.0, 1.0/16.0};

    float3 resColor = 0.0.xxx;
    float wSum = 0.0;

    for (int x = -1; x <= 1; ++x)
      for (int y = -1; y <= 1; ++y)
      {
        float h_i = h[abs(x) + abs(y)];
        int2 tcOffset = int2(x,y) * GIBS_IndirectLightSpatialFilterScope.stepSize;
        uint3 sampleTC = uint3(clamp(tc.xy + tcOffset, 0.xx, renderSize - 1.xx), 0);

        float3 sampleNormal = unpackMaterialNormal(sampleTC).rgb;
        float sampleDepth = gbufferDepth.Load(sampleTC).r;
        float3 sampleColor = filterInput.Load(sampleTC).rgb;
        float sampleLuminance = luminance(sampleColor);

        float w_normal = SVGF_normalWeight(normal, sampleNormal);
        float w_depth = SVGF_depthWeight(depth, sampleDepth, depthGrad, tcOffset);
        float w_luminance = SVGF_luminanceWeight(pLuminance, sampleLuminance, Var);

        float w_i = w_normal * w_depth * w_luminance * h_i;
        wSum += w_i;
        resColor += w_i * sampleColor;
      }
    
    resColor /= wSum;

    filterOutput[tc.xy] = float4(resColor, 1.0);
  }
  #end

  compile(cs, cs_main);
};