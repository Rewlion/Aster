#include <materials.inc.tfx>
#include <color_spaces.inc.tfx>
#include <depth.inc.tfx>
#include <frame.inc.tfx>

scope GIBS_IndirectLightSpatialFilterScope
{
  reserve:
    descriptor_set(1);
    register(texture, 0-4);
    register(buffer, 0);

  int stepSize = extern(stepSize);
  uint2 dispatchDim = extern(dispatchDim);

  Texture2D filterInput = extern(filterInput);
  RWTexture2D<float4> filterOutput = extern(filterOutput);

  Texture2D gbufferNormal = extern(gbuffer_normal);
  Texture2D gbufferDepth = extern(gbuffer_depth);
};

technique GIBS_IndirectLightSpatialFilter
{
  support scope FrameScope;
  activate scope GIBS_IndirectLightSpatialFilterScope;

  USE_MATERIALS_NORMAL_UNPACK();
  USE_COLOR_SPACES();
  USE_DEPTH_UTILS();
  USE_FRAME_HELPERS();

  #hlsl

  #include <ThreadGroupTilingX.hlsl>

  float SVGF_normalWeight(float3 normal, float3 sample_normal)
  {
    int sigma = 128;
    return pow(max(0, dot(normal, sample_normal) ), sigma);
  }

  float planeDistance(float3 wpos, float3 sample_wpos, float3 plane_normal)
  {
    return abs(dot(wpos - sample_wpos, plane_normal));
  }

  float SVGF_depthWeight(float3 wpos, float3 sample_wpos, float3 normal)
  {
    return planeDistance(wpos, sample_wpos, normal) < 0.01 ? 1.0 : 0.0;
  }

  float SVGF_luminanceWeight(float luminance, float sample_luminance, float Var)
  {
    float eps = 0.005;
    float sigma = 4.0;
    return exp(- abs(sample_luminance - luminance) / (sigma * Var + eps));
  }

  #define KERNEL_RADIUS 1
  #define TILING_N 16

  [numthreads(8,8,1)]
  void cs_main(uint2 group_thread_id : SV_GroupThreadID, uint2 group_id : SV_GroupID, uint3 dispatch_thread_id : SV_DispatchThreadID)
  {
    uint2 renderSize;
    filterInput.GetDimensions(renderSize.x, renderSize.y);

    uint3 tc = uint3(ThreadGroupTilingX(
      GIBS_IndirectLightSpatialFilterScope.dispatchDim,
      uint2(8,8),
      TILING_N,
      group_thread_id,
      group_id
    ), 0);

    if (any(tc.xy > renderSize))
      return;

    float depth = gbufferDepth.Load(tc).r;
    if (depth == 0.0)
    {
      filterOutput[tc.xy] = 0.xxxx;
      return;
    }

    float3 farPlanePoint = getFarPlanePoint(tc.xy, renderSize);
    float3 wpos = calcWorldPosITM(tc.xy, renderSize, depth);
    float3 normal = unpackMaterialNormal(tc);
    float3 color = filterInput.Load(tc).rgb;
    float pLuminance = luminance(color);
    float Var = 1.0;//variance.Load(tc).r;

    float h[3] = {3.0/8.0, 1.0/4.0, 1.0/16.0};

    float3 resColor = color * h[0];
    float wSum = h[0];

    for (int y = -KERNEL_RADIUS; y <= KERNEL_RADIUS; ++y)
      for (int x = -KERNEL_RADIUS; x <= KERNEL_RADIUS; ++x)
      {
        if (x == 0 && y == 0)
          continue;

        float h_i = h[abs(x)]*h[abs(y)];
        int2 tcOffset = int2(x,y) * GIBS_IndirectLightSpatialFilterScope.stepSize;
        int3 sampleTC = int3(tc.xy + tcOffset, 0);

        if (any(sampleTC.xy < 0) || any(sampleTC.xy >= renderSize))
          continue;

        float3 sampleNormal = unpackMaterialNormal(sampleTC).rgb;
        float sampleDepth = gbufferDepth.Load(sampleTC).r;
        float3 sampleWpos = calcWorldPosITM(sampleTC.xy, renderSize, sampleDepth);
        float3 sampleColor = filterInput.Load(sampleTC).rgb;
        float sampleLuminance = luminance(sampleColor);

        float w_normal = SVGF_normalWeight(normal, sampleNormal);
        float w_depth = SVGF_depthWeight(wpos, sampleWpos, normal);
        float w_luminance = SVGF_luminanceWeight(pLuminance, sampleLuminance, Var);

        float w_i = w_normal * w_depth * w_luminance * h_i;
        wSum += w_i;
        resColor += w_i * sampleColor;
      }
    
    resColor /= wSum;

    filterOutput[tc.xy] = float4(resColor, 1.0);
  }
  #end

  compile(cs, cs_main);
};