#include "atmosphere/atmosphere.inc.tfx"
#include "atmosphere/envi.inc.tfx"
#include "atmosphere/sph.inc.tfx"
#include "depth.inc.tfx"
#include "frame.inc.tfx"
#include "materials.inc.tfx"
#include "math.inc.tfx"
#include "pbr.inc.tfx"
#include "screen_space.inc.tfx"

scope ResolveGbufferScope {
  reserve:
    descriptor_set(3);
    register(buffer, 0-1);
    register(texture, 0-5);

  RWStructuredBuffer<float3> atmParamsBuffer = extern(atmParamsBuffer);

  Texture2D gbufferAlbedo = extern(gbuffer_albedo);
  Texture2D gbufferNormal = extern(gbuffer_normal);
  Texture2D gbufferMetalRoughness = extern(gbuffer_metal_roughness);
  Texture2D gbufferDepth = extern(gbuffer_depth);
  Texture2D enviSpecular = extern(enviSpecular);
  Texture2D enviBRDF = extern(enviBRDF);

  float enviMips = extern(enviMips);
  float4 sunAzimuth_sunAltitude_rTopMM_rBotMM = channel(sunAzimuth_sunAltitude_rTopMM_rBotMM);
};

technique ResolveGbuffer {
  activate scope ResolveGbufferScope;
  support scope FrameScope;

  render_state:
    primitive_topology = triangle_strip;
    depth:
     test = no;
     write = no;

  USE_MATH();
  #hlsl
  #include "atmosphere/sph.hlsl"
  #end
  USE_ATMOSPHERE_PARAMS();
  USE_ATM_SPH();

  USE_SCREENSPACE_VIEW_BASE();
  USE_ENVI_IBL();
  USE_MATERIALS_UNPACKING();
  USE_DEPTH_UTILS();
  USE_PBR();

  #hlsl
    float3 deferredLight(VsOutput input)
    {
      uint3 tc = uint3(input.pos.xy, 0);
      ProcessedMaterial mat = processMaterial(unpackMaterial(tc));

      float depth = gbufferDepth.Load(tc).r;
      float3 worldPos = calcWorldPos(FrameScope.cameraPos, input.viewDir, depth, FrameScope.zNear_zFar.x, FrameScope.zNear_zFar.y);

      float3 N = mat.normal;
      float3 L = getAtmSunDir();
      float3 V = normalize(FrameScope.cameraPos - worldPos);
      float3 H = normalize(L+V);
      float3 R = reflect(-V,N);

      float NoL = max(dot(L, N), 0.0);
      float NoV = max(dot(V,N), 0.0);
      float VoH = max(dot(V,H), 0.0);

      float3 F = schlickFresnel(mat.specularReflection, VoH).rgb;
      float3 kD = (1.0 - F);

      float3 diffuseSPH = getSphDiffuseProbe(N);
      float3 sunL = getSunL() * NoL;

      float3 diffusePart = diffuseBRDF(mat.diffuseColor, mat.specularReflection, VoH) * (diffuseSPH + sunL);
      float3 specularPart = enviSpecularIBL(mat.specularReflection, mat.roughness, NoV, R);

      float3 Lo = diffusePart + specularPart;

      return Lo;
    }

    float4 ps_main(VsOutput input) : SV_Target0
    {
      return float4(deferredLight(input), 1.0);
    }
  #end

  compile(vs_6_1, vs_main);
  compile(ps_6_1, ps_main);
};