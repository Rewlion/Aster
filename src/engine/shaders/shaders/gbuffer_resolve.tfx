#include "atmosphere/atmosphere.inc.tfx"
#include "atmosphere/envi.inc.tfx"
#include "atmosphere/sph.inc.tfx"
#include "depth.inc.tfx"
#include "frame.inc.tfx"
#include "materials.inc.tfx"
#include "math.inc.tfx"
#include "pbr.inc.tfx"
#include "screen_space.inc.tfx"

scope ResolveGbufferScope {
  reserve:
    descriptor_set(2);
    register(buffer, 0-4);
    register(texture, 0-9);

  RWStructuredBuffer<float3> atmParamsBuffer = extern(atmParamsBuffer);
  
  RWTexture2D<float4> resolveTarget = extern(resolveTarget);
  Texture2D gbufferAlbedo = extern(gbuffer_albedo);
  Texture2D gbufferNormal = extern(gbuffer_normal);
  Texture2D gbufferMetalRoughness = extern(gbuffer_metal_roughness);
  Texture2D gbufferDepth = extern(gbuffer_depth);
  Texture2D enviSpecular = extern(enviSpecular);
  Texture2D enviBRDF = extern(enviBRDF);
  Texture2D prevPostProcessInput = extern(prevPostProcessInput);
  Texture2D motionBuf = extern(motionBuf);
  Texture2D hiZ = extern(hi_z_buffer);

  #hlsl
  #include "clustered_light/utils.hlsl"
  #end

  StructuredBuffer<Light> lightBuffer = extern(clustersLightBuffer);
  StructuredBuffer<ClusterInfo> clustersInfoBuffer = extern(clustersInfoBuffer);
  StructuredBuffer<ClusterIndirection> indirectionBuffer = extern(clustersIndirectionBuffer);

  float enviMips = extern(enviMips);
  float4 sunAzimuth_sunAltitude_rTopMM_rBotMM = channel(sunAzimuth_sunAltitude_rTopMM_rBotMM);
};

technique ResolveGbuffer {
  activate scope ResolveGbufferScope;
  support scope FrameScope;

  render_state:
    primitive_topology = triangle_strip;
    depth:
     test = no;
     write = no;

  USE_MATH();
  #hlsl
  #include "atmosphere/sph.hlsl"
  #end
  USE_ATMOSPHERE_PARAMS();
  USE_ATM_SPH();

  USE_ENVI_IBL();
  USE_MATERIALS_UNPACKING();
  USE_DEPTH_UTILS();
  USE_PBR();

  #hlsl
    #include "clustered_light/lights_apply.hlsl"

    #define SSR_MAX_DISTANCE 60.0
    #define FLOAT_MAX 3.402823466e+38

    //advance once cell forward to skip self intersection
    float3 initRaySample(float3 begin, float3 dir, float3 inv_dir, float2 cell_border_step, float2 cell_uv_offset, float2 init_cells_count)
    {
      float2 cell = floor(begin.xy * init_cells_count);
      float2 xyBorders = (cell + cell_border_step) / init_cells_count + cell_uv_offset;
      float2 t = (xyBorders - begin.xy) * inv_dir.xy;
      return begin + dir * min(t.x, t.y);
    }

    bool advanceRaySample(float3 dir, float3 inv_dir, float2 cell_border_step, float2 cell_uv_offset, float2 cells_count, float depth_plane, float hi_z_level, inout float3 ray_sample)
    {
      float2 cell = floor(ray_sample.xy * cells_count);
      float2 xyBorders = (cell + cell_border_step) / cells_count + cell_uv_offset;
      float zBorder = depth_plane;
      float3 borders = float3(xyBorders, zBorder);
      float3 t = (borders - ray_sample) * inv_dir;

      t.z = dir.z < 0 ? t.z : FLOAT_MAX;
      float tMin = min(t.x, min(t.y, t.z));
      bool isAboveDepthPlane = ray_sample.z > zBorder;

      ray_sample = isAboveDepthPlane ? ray_sample + dir * tMin : ray_sample;

      bool crossedBorders = asuint(tMin) != asuint(t.z) && isAboveDepthPlane;
      return crossedBorders;
    }

    float3 ssr(float3 view_dir, float3 R, float3 worldPos, float2 screen_size)
    {
      float cameraFacingReflectionAttenuation = 1 - smoothstep(0.25, 0.5, dot(-view_dir, R));
      if (cameraFacingReflectionAttenuation <= 0)
        return float3(0,0,0);

      float maxDist = 5.0;
      float3 endWorldPos = worldPos + R*maxDist;

      float4 beginVS = mul(FrameScope.view, float4(worldPos, 1));
      if (beginVS.z >= SSR_MAX_DISTANCE)
        return float3(0,0,0);

      float4 beginSS = mul(FrameScope.viewProj, float4(worldPos, 1));
      beginSS.xyz /= beginSS.w;
      beginSS.xy = (beginSS.xy) * float2(0.5, -0.5) + 0.5;
      beginSS.xy = (floor(beginSS.xy * screen_size) + 0.5) / screen_size;

      float4 endSS = mul(FrameScope.viewProj, float4(endWorldPos, 1));
      endSS.xyz /= endSS.w;
      endSS.xy = endSS.xy * float2(0.5, -0.5) + 0.5;

      float2 deltaPixels = (beginSS.xy -  endSS.xy) * screen_size ;
      uint maxDeltaPixels = max(max(abs(deltaPixels.x), abs(deltaPixels.y)), 1);

      float2 cellsCount;
      hiZ.GetDimensions(cellsCount.x, cellsCount.y);

      float3 rayDir = (endSS.xyz - beginSS.xyz);

      float3 invRayDir = rcp(rayDir);
      float2 cellBorderStep = rayDir.xy <= 0 ? 0 : 1;
      float2 cellUvOffset = 0.005 / cellsCount;
      cellUvOffset = rayDir.xy < 0 ? -cellUvOffset : cellUvOffset;
      
      float3 raySample = initRaySample(beginSS.xyz, rayDir, invRayDir, cellBorderStep, cellUvOffset, cellsCount);

      uint maxHiZLevel = 10;
      uint maxIterations = 100;
      int hiZLevel = 0;
      uint iterations = 0;

      while (hiZLevel >= 0 && hiZLevel < maxHiZLevel && iterations < maxIterations && (all(raySample.xy > 0) && all(raySample.xy < 1)))
      {
        float nLevels;
        hiZ.GetDimensions(hiZLevel, cellsCount.x, cellsCount.y, nLevels);

        float2 tc = raySample.xy * cellsCount;
        int3 pos = int3(tc, hiZLevel);
        float depthPlane = hiZ.Load(pos).r;
        bool crossedBorders = advanceRaySample(rayDir, invRayDir, cellBorderStep, cellUvOffset, cellsCount, depthPlane, hiZLevel, raySample);

        hiZLevel += crossedBorders ? 1 : -1;
        ++iterations;
      }

      bool validHit = hiZLevel < 0 && raySample.z > 0;
      
      if (validHit)
      {
        uint3 tc = uint3((uint2)(raySample.xy * screen_size), 0);
        float2 motionVec = motionBuf.Load(tc).rg * float2(0.5, -0.5);
        float3 reflection = prevPostProcessInput.SampleLevel(linearClampSampler, raySample.xy - motionVec, 0).rgb;
        return reflection;
      }
      
      return float3(0.0, 0.0, 0.0);
    }

    [numthreads(TILE_DIM_X, TILE_DIM_Y, 1)]
    void cs_main(uint3 dispatch_thread_id: SV_DispatchThreadID)
    {
      uint2 renderSize;
      resolveTarget.GetDimensions(renderSize.x, renderSize.y);

      if (any(dispatch_thread_id.xy >= renderSize))
        return;

      uint3 tc = dispatch_thread_id;
      float depth = gbufferDepth.Load(tc).r;

      if (depth == 0.0)
        return;

      float3 leftRight = FrameScope.rtView_WS - FrameScope.ltView_WS;
      float3 topBot = FrameScope.lbView_WS - FrameScope.ltView_WS;

      float2 t = float2(tc.xy) / float2(renderSize - uint2(1, 1));
      float3 farPlainPoint = FrameScope.ltView_WS + leftRight * t.x + topBot * t.y;
      float3 viewDir = normalize(farPlainPoint);

      ProcessedMaterial mat = processMaterial(unpackMaterial(tc));

      float3 worldPos = calcWorldPos(FrameScope.cameraPos, farPlainPoint, depth, FrameScope.zNear_zFar.x, FrameScope.zNear_zFar.y);

      float3 N = mat.normal;
      float3 L = getAtmSunDir();
      float3 V = normalize(FrameScope.cameraPos - worldPos);
      float3 H = normalize(L+V);
      float3 R = reflect(-V,N);

      float NoL = max(dot(L, N), 0.0);
      float NoV = max(dot(V,N), 0.0);
      float VoH = max(dot(V,H), 0.0);
      float NoH = max(dot(N,H), 0.0);

      DynamicLightsApplyParams dynamicLightParams;
      dynamicLightParams.tc = tc.xy;
      dynamicLightParams.renderSize = renderSize;
      dynamicLightParams.worldPos = worldPos;
      dynamicLightParams.N = N;
      dynamicLightParams.NoV = NoV;
      dynamicLightParams.NoH = NoH;
      dynamicLightParams.VoH = VoH;
      dynamicLightParams.zView = linearize_z(depth, FrameScope.zNear_zFar.x, FrameScope.zNear_zFar.y);
      dynamicLightParams.zNear = FrameScope.zNear_zFar.x;
      dynamicLightParams.zFar = FrameScope.zNear_zFar.y;
      dynamicLightParams.roughness = mat.roughness;
      dynamicLightParams.ggxAlpha = mat.ggxAlpha;
      dynamicLightParams.specularReflection = mat.specularReflection;
      dynamicLightParams.clustersInfoBuffer = clustersInfoBuffer;
      dynamicLightParams.indirectionBuffer = indirectionBuffer;
      dynamicLightParams.lightBuffer = lightBuffer;

      float3 dynamicLightsDiffuseNoBRDF;
      float3 dynamicLightsSpecular;
      dynamicLights(dynamicLightParams, dynamicLightsDiffuseNoBRDF, dynamicLightsSpecular);

      float3 diffuseSPH = getSphDiffuseProbe(N);
      float3 sunL = getSunL() * NoL;

      float3 diffusePart = diffuseBRDF(mat.diffuseColor, mat.specularReflection, VoH) * (diffuseSPH + sunL + dynamicLightsDiffuseNoBRDF);

      float3 ssrPart = ssr(viewDir, reflect(viewDir, N), worldPos, float2(renderSize));
      float3 specularPart = ssrPart;

      float3 Lo = diffusePart + specularPart;
      
      resolveTarget[tc.xy] = float4(Lo, 1.0);
    }
  #end

  compile(cs, cs_main);
};