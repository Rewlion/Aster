technique_macro USE_MATERIALS_BASE
{
  #hlsl
  struct UnpackedMaterial
  {
    float3 albedo;
    float metal;
    float roughness;
    float3 normal;
    float2 motion;
  };

  struct PackedMaterial
  {
    float3 albedo         : SV_Target0;
    float3 normal         : SV_Target1;
    float3 metalRoughness : SV_Target2;
    float3 motion         : SV_Target3;
  };
  #end
};

technique_macro USE_MATERIALS_PACKING
{
  USE_MATERIALS_BASE();

  #hlsl
  void initAlbedo(inout UnpackedMaterial m, float3 albedo)
  {
    m.albedo = albedo;
  }

  void initMetal(inout UnpackedMaterial m, float metal)
  {
    m.metal = metal;
  }

  void initRoughness(inout UnpackedMaterial m, float roughness)
  {
    m.roughness = roughness;
  }

  void initNormal(inout UnpackedMaterial m, float3 normal)
  {
    m.normal = normal;
  }

  float2 calcMotion(float4 prev_pos, float4 cur_pos)
  {
    prev_pos /= prev_pos.w;
    cur_pos /= cur_pos.w;
    return (cur_pos - prev_pos).xy;
  }

  void initMotionVector(inout UnpackedMaterial m, float4 prev_pos, float4 cur_pos)
  {
    m.motion = calcMotion(prev_pos, cur_pos);
  }

  PackedMaterial packMaterial(UnpackedMaterial m)
  {
    PackedMaterial output = (PackedMaterial)0;
    output.albedo = m.albedo.rgb;
    output.normal = (m.normal + 1.0) * 0.5;
    output.metalRoughness = float3(m.metal, m.roughness, 0.0f);
    output.motion = float3(m.motion, 0.0);
    return output;
  }
  #end
};

technique_macro USE_MATERIALS_NORMAL_UNPACK
{
  #hlsl
  float3 unpackNormal(float3 packed_val)
  {
    return packed_val / 0.5f - 1.0f;
  }
  
  float3 unpackMaterialNormal(uint3 tc)
  {
    return unpackNormal(gbufferNormal.Load(tc).rgb);
  }
  #end
};

technique_macro USE_MATERIALS_ROUGHNESS_UNPACK
{
  #hlsl
  float unpackMaterialRoughness(uint3 tc)
  {
    return gbufferMetalRoughness.Load(tc).g;
  }
  #end
};

technique_macro USE_MATERIALS_UNPACKING
{
  USE_MATERIALS_BASE();

  USE_MATERIALS_NORMAL_UNPACK();
  USE_MATERIALS_ROUGHNESS_UNPACK();

  #hlsl
  struct ProcessedMaterial
  {
    float metal;
    float roughness;
    float ggxAlpha;
    float3 normal;

    float3 diffuseColor;
    float3 specularReflection;

    float3 albedo;
  };

  float3 calcFresnelSpecularReflection(float3 baseColor, float metal, float reflectance)
  {
    float f0Dielectric = 0.16 * pow(reflectance, 2.0);
    return lerp(float3(f0Dielectric,f0Dielectric,f0Dielectric), baseColor, metal);
  }

  UnpackedMaterial unpackMaterial(uint3 tc)
  {
    float3 albedo = gbufferAlbedo.Load(tc).rgb;
    float3 normal = unpackMaterialNormal(tc);
    float2 metalRoughness = gbufferMetalRoughness.Load(tc).rg;

    UnpackedMaterial o = (UnpackedMaterial)0;
    o.albedo = albedo;
    o.metal = metalRoughness.r;
    o.roughness = metalRoughness.g;
    o.normal = normal;

    return o;
  }

  ProcessedMaterial processMaterial(UnpackedMaterial m)
  {
    ProcessedMaterial o;
    o.albedo = m.albedo;
    o.metal = m.metal;
    o.roughness = m.roughness;
    o.ggxAlpha = roughnessToGGXAlpha(m.roughness);
    o.normal = m.normal;
    o.diffuseColor = (1.0 - m.metal) * m.albedo;
    o.specularReflection = calcFresnelSpecularReflection(m.albedo, m.metal, 0.5);

    return o;
  }
  #end
};
