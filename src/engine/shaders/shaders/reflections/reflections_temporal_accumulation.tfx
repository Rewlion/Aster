#include <frame.inc.tfx>
#include <materials.inc.tfx>
#include <depth.inc.tfx>
#include <color_spaces.inc.tfx>

scope Reflections_TemporalAccumulationScope
{
  reserve:
    descriptor_set(1);
    register(texture, 0-9);

  RWTexture2D<float4> taOutput = extern(taOutput);
  Texture2D taHistory = extern(taHistory);
  Texture2D inputIrradiance = extern(inputIrradiance);
  RWTexture2D<float> varianceOutput = extern(varianceOutput);
  Texture2D varianceHistory = extern(varianceHistory);

  Texture2D motionBuf = extern(motionBuf);
  Texture2D gbufferNormal = extern(gbuffer_normal);
  Texture2D gbufferNormal_prev = extern(gbuffer_normal_prev);
  Texture2D gbufferDepth = extern(gbuffer_depth);
  Texture2D gbufferDepth_prev = extern(gbuffer_depth_prev);
};

technique Reflections_TemporalAccumulation
{
  support scope FrameScope;
  activate scope Reflections_TemporalAccumulationScope;

  USE_FRAME_HELPERS();
  USE_MATERIALS_MOTION_VEC_UNPACK();
  USE_MATERIALS_NORMAL_UNPACK();
  USE_DEPTH_UTILS();
  USE_COLOR_SPACES();

  #hlsl

  // float planeDistance(float3 wpos, float3 wpos_history, float3 plane_normal)
  // {
  //   float3 dl = wpos - wpos_history;
  //   return abs(dot(dl, plane_normal));
  // }

  bool isHistoryValid(uint3 tc, int2 history_tc_reprojected, float depth, uint2 render_size)
  {
    float3 normal = unpackNormal(gbufferNormal.Load(tc).rgb);
    float3 normalHistory = 0.xxx;

    uint3 historyTC = uint3(history_tc_reprojected, 0);
    float depthHistory = gbufferDepth_prev.Load(historyTC).r;

    if (depthHistory != 0.0)
      normalHistory = unpackNormal(gbufferNormal_prev.Load(historyTC).rgb);

    const bool passedDepthDisocclusion = abs(depthHistory - depth) < 0.001;
    const bool passedNormalDisocclusion = dot(normal, normalHistory) > 0.99;

    return passedDepthDisocclusion && passedNormalDisocclusion;
  }

  float calcLuminanceVariance(float3 irradiance, float3 history_irradiance)
  {
    float curLuminance = luminance_ub(irradiance);
    float historyLuminance = luminance_ub(history_irradiance);
    float diff = (curLuminance - historyLuminance);
    return diff * diff;
  }

  void estimateNeighborBBox(int2 tc, int2 render_size, float3 center_irradiance, out float3 rgb_min, out float3 rgb_max)
  {
    float3 E_x = center_irradiance;
    float3 E_x2 = center_irradiance*center_irradiance;

    float w = 1;

    for (int y = -1; y <= 1; ++y)
    for (int x = -1; x <= 1; ++x)
    {
      if (x == 0 && y == 0)
        continue;

      int2 sampleTC = tc + int2(x,y);
      if (any(sampleTC < 0) || any(sampleTC >= render_size))
        continue;

      float3 irradiance = inputIrradiance.Load(uint3(sampleTC,0)).rgb;
      float w_i = exp( - 3.0 * (x*x + y*y) / (5.0*5.0) );

      E_x += irradiance * w_i;
      E_x2 += irradiance*irradiance*w_i;
      w += w_i;
    }

    E_x /= w;
    E_x2 /= w;

    float3 Var = E_x2 - E_x*E_x;

    rgb_min = E_x - Var;
    rgb_max = E_x + Var;
  }

  [numthreads(8,8,1)]
  void cs_main(uint3 dispatch_thread_id : SV_DispatchThreadID)
  {
    uint2 renderSize;
    taOutput.GetDimensions(renderSize.x, renderSize.y);

    if (any(dispatch_thread_id.xy >= renderSize))
      return;

    uint3 tc = uint3(dispatch_thread_id.xy, 0);

    float depth = gbufferDepth.Load(tc).r;
    if (depth == 0.0)
    {
      taOutput[tc.xy] = 0.xxxx;
      return;
    }

    float3 irradiance = inputIrradiance.Load(tc).rgb;
    int2 historyTCReprojected = reprojectFrameTC(tc, renderSize);

    [BRANCH]
    if (all(historyTCReprojected >= 0) && all(historyTCReprojected < renderSize))
    {
      float3 rgbBBoxMin, rgbBBoxMax;
      estimateNeighborBBox(tc.xy, renderSize, irradiance, rgbBBoxMin, rgbBBoxMax);

      float3 historyIrradiance = taHistory.Load(uint3(historyTCReprojected, 0)).rgb;
      float historyVar = varianceHistory.Load(uint3(historyTCReprojected, 0)).r;
      
      bool useHistory = isHistoryValid(tc, historyTCReprojected, depth, renderSize);

      float Var = calcLuminanceVariance(irradiance, historyIrradiance);
      float resVariance = useHistory ? lerp(historyVar, Var, 0.2) : 1.0;
      
      float w = useHistory ? 0.2 : 1.0;
      float3 resColor = lerp(historyIrradiance, irradiance, w);

      float3 clampedColor = clamp(resColor, rgbBBoxMin, rgbBBoxMax);

      taOutput[tc.xy] = float4(clampedColor,1);
      varianceOutput[tc.xy] = resVariance;
    }
    else
    {
      taOutput[tc.xy] = float4(irradiance, 0);
      varianceOutput[tc.xy] = 1.0;
    }
  }
  #end

  compile(cs, cs_main);
};