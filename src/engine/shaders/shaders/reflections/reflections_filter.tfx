#include <materials.inc.tfx>
#include <depth.inc.tfx>
#include <frame.inc.tfx>

scope Reflections_SpatialFilterScope
{
  reserve:
    descriptor_set(1);
    register(texture, 0-5);
    register(buffer, 0);

  int stepSize = extern(stepSize);
  uint2 dispatchDim = extern(dispatchDim);

  Texture2D variance = extern(variance);
  Texture2D filterInput = extern(filterInput);
  RWTexture2D<float4> filterOutput = extern(filterOutput);

  Texture2D gbufferNormal = extern(gbuffer_normal);
  Texture2D gbufferDepth = extern(gbuffer_depth);
  Texture2D gbufferMetalRoughness = extern(gbuffer_metal_roughness);
};

technique Reflections_SpatialFilter
{
  support scope FrameScope;
  activate scope Reflections_SpatialFilterScope;

  USE_MATERIALS_NORMAL_UNPACK();
  USE_DEPTH_UTILS();
  USE_FRAME_HELPERS();

  #hlsl

  #include <color_spaces.hlsl>
  #include <ThreadGroupTilingX.hlsl>

  float SVGF_normalWeight(float3 normal, float3 sample_normal)
  {
    int sigma = 128;
    return pow(max(0, dot(normal, sample_normal) ), sigma);
  }

  float planeDistance(float3 wpos, float3 sample_wpos, float3 plane_normal)
  {
    return abs(dot(wpos - sample_wpos, plane_normal));
  }

  float SVGF_depthWeight(float3 wpos, float3 sample_wpos, float3 normal)
  {
    return planeDistance(wpos, sample_wpos, normal) < 0.01 ? 1.0 : 0.0;
  }

  float SVGF_luminanceWeight(float luminance, float sample_luminance, float Var)
  {
    float eps = 0.005;
    float sigma = 4.0;
    return exp(- abs(sample_luminance - luminance) / (sigma * abs(Var) + eps));
  }

  #define KERNEL_RADIUS 1
  #define TILING_N 16

  [numthreads(8,8,1)]
  void cs_main(uint2 group_thread_id : SV_GroupThreadID, uint2 group_id : SV_GroupID)
  {
    uint2 renderSize;
    filterInput.GetDimensions(renderSize.x, renderSize.y);

    uint2 tc = ThreadGroupTilingX(
      Reflections_SpatialFilterScope.dispatchDim,
      uint2(8,8),
      TILING_N,
      group_thread_id,
      group_id
    );

    if (any(tc.xy > renderSize))
      return;

    float2 uv = (float2(tc) + 0.5) / renderSize;

    float depth = gbufferDepth.SampleLevel(pointClampSampler, uv, 0).r;

    if (depth == 0.0)
    {
      filterOutput[tc.xy] = 0.xxxx;
      return;
    }
    
    float roughness = gbufferMetalRoughness.SampleLevel(pointClampSampler, uv, 0).g;
    bool isMirrorLike = roughness <= 0.05;

    float3 color = filterInput.SampleLevel(pointClampSampler, uv, 0).rgb;
    if (isMirrorLike)
    {
      filterOutput[tc.xy] = float4(color,0);
      return;
    }

    float Var = variance.SampleLevel(pointClampSampler, uv, 0).r;
    float3 normal = unpackNormal(gbufferNormal.SampleLevel(pointClampSampler, uv, 0).rgb);
    float3 farPlanePoint = getFarPlanePoint(tc.xy, renderSize);
    float3 wpos = calcWorldPosITM(tc.xy, renderSize, depth);
    float pLuminance = luminance(color);

    float h[3] = {3.0/8.0, 1.0/4.0, 1.0/16.0};

    float3 resColor = color * h[0];
    float wSum = h[0];

    for (int y = -KERNEL_RADIUS; y <= KERNEL_RADIUS; ++y)
      for (int x = -KERNEL_RADIUS; x <= KERNEL_RADIUS; ++x)
      {
        if (x == 0 && y == 0)
          continue;

        float h_i = h[abs(x)]*h[abs(y)];
        int2 tcOffset = int2(x,y) * Reflections_SpatialFilterScope.stepSize;
        int2 sampleTC = tc.xy + tcOffset;

        float2 sampleUV = (float2(sampleTC) + 0.5) / renderSize;
        if (any(sampleUV < 0) || any(sampleUV > renderSize))
          continue;

        float3 sampleNormal = unpackNormal(gbufferNormal.SampleLevel(pointClampSampler, sampleUV, 0).rgb);
        float sampleDepth = gbufferDepth.SampleLevel(pointClampSampler, sampleUV, 0).r;
        float3 sampleColor = filterInput.SampleLevel(pointClampSampler, sampleUV, 0).rgb;

        float3 sampleWpos = calcWorldPosITM(sampleTC.xy, renderSize, sampleDepth);
        float sampleLuminance = luminance(sampleColor);

        float w_normal = SVGF_normalWeight(normal, sampleNormal);
        float w_depth = SVGF_depthWeight(wpos, sampleWpos, normal);
        float w_luminance = SVGF_luminanceWeight(pLuminance, sampleLuminance, Var);

        float w_i = w_normal * w_depth * w_luminance * h_i;
        wSum += w_i;
        resColor += w_i * sampleColor;
      }
    
    resColor /= wSum;

    filterOutput[tc.xy] = float4(resColor, 1.0);
  }
  #end

  compile(cs, cs_main);
};