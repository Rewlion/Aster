scope ReflectionsFilterScope
{
  reserve:
    descriptor_set(2);
    register(texture, 0-1);
  
  Texture2D<float4> blurInput = extern(blurInput);
  RWTexture2D<float4> blurOutput = extern(blurOutput);
};

technique ReflectionsFilter
{
  activate scope ReflectionsFilterScope;
  
  #hlsl
  #include "reflections_filter.hlsl"

  #define MAX_RANGE 64
  #define RANGE 11
  #define RANGE_BORDER (RANGE-1)/2
  #define SIGMA_S 64.0
  #define SIGMA_R 0.01

  float gauss_kernel(float sigma, float range)
  {
    float oneOverSqrtTwoPi = 0.39894;
    float oneOverSigmaSq = 1.0 / (sigma*sigma);
    return oneOverSqrtTwoPi * oneOverSigmaSq * exp(-(range*range) * oneOverSigmaSq * 0.5);
  }

  float intencity(float3 rgb)
  {
    float cMax = max(max(rgb.r, rgb.g), rgb.b);
    float cMin = min(min(rgb.r, rgb.g), rgb.b);
    float d = cMax - cMin;
    return d == 0.0 ? 0.0 : d / cMax;
  }

  [numthreads(BLF_TILE_DIM_X, BLF_TILE_DIM_X, 1)]
  void cs_main(uint3 dispatch_thread_id : SV_DispatchThreadID)
  {
    uint2 renderSize;
    blurInput.GetDimensions(renderSize.x, renderSize.y);
    if (any(dispatch_thread_id.xy > renderSize))
     return;
    
    //blurOutput[dispatch_thread_id.xy] = blurInput.Load(dispatch_thread_id.xyz); return;

    // float spatial_gauss_kernels[RANGE];
    // for (int r = 0; r < RANGE_BORDER; ++r)
    //   spatial_gauss_kernels[RANGE_BORDER+r] = spatial_gauss_kernels[RANGE_BORDER-r] = gauss_kernel(SIGMA, float(r));

    float Wp = 0;
    uint2 p = dispatch_thread_id.xy;

    float3 Ip = blurInput.Load(uint3(p,0)).rgb;
    float3 BFp = float3(0,0,0);

    for (int i = -RANGE_BORDER; i <= RANGE_BORDER; ++i)
    {
      for (int j = -RANGE_BORDER; j <= RANGE_BORDER; ++j)
      {
        int2 q = p + int2(i,j);
        if (any(q < 0 || q > renderSize))
          continue;

        float3 Iq = blurInput.Load(uint3(q,0)).rgb;
        float spatialDist = dot(q-p, q-p);
        float colorDist = intencity(Iq) - intencity(Ip);//dot(Iq-Ip, Iq-Ip);
        //float colorDist = dot(Iq-Ip, Iq-Ip) * 255.0;
        float Wp_ij = gauss_kernel(SIGMA_S, spatialDist) * gauss_kernel(SIGMA_R, colorDist);
        //float Wp_ij = gauss_kernel(SIGMA_R, colorDist);

        Wp += Wp_ij;
        BFp += Wp_ij * Iq;
      }
    }

    BFp = BFp / Wp;

    blurOutput[dispatch_thread_id.xy] = float4(BFp, 1.0);
  }

  #end

  compile(cs, cs_main);
};