#include <frame.inc.tfx>
#include <materials.inc.tfx>
#include "virtual_texture.tfx"

scope TerrainScope
{
  reserve:
    descriptor_set(2);
    register(buffer, 0-1);
    register(texture, 0-4);

  Texture2D heightmap = channel(terrainHeightmap);
  Texture2D fallback = channel(terrainAlbedo);
  float worldMapSize = channel(worldMapSize);
  float2 minMaxHeightBorder = channel(terrainMinMaxHeightBorder);
  float maxHeight = channel(terrainMaxHeight);

  RWStructuredBuffer<float4> patches = extern(terrainPatches);
  RWTexture2D<uint> feedbackBuf = extern(terrainFeedbackBuf);
  float2 feedbackSize = extern(terrainFeedbackSize);
};

technique Terrain
{
  support scope FrameScope;
  activate scope TerrainScope;
  support scope VTexParamsScope;
  support scope VTexSampleScope;

  render_state:
    polygon_mode = fill;
    primitive_topology = patch_list;

  USE_MATERIALS_PACKING();
  USE_VTEX_UNPACK();

  #hlsl
  #include "edge_factor.hlsli"

  struct HsInput
  {
    uint vertexId: TEXCOORD0;
  };

  HsInput vs_main(uint vertexId: SV_VertexID)
  {
    HsInput output;
    output.vertexId = vertexId;

    return output;
  }

  struct HsPatchData
  {
    float edges[4] : SV_TessFactor;
    float inside[2] : SV_InsideTessFactor;
  };

  #define TessFactor 64.0

  void getPatchParams(uint vertexId, out float2 world_xz, out float size, out uint edge_factor)
  {
    float4 params = patches.Load(vertexId);
    world_xz = params.xy;
    size = params.z;
    edge_factor = (uint)params.w;
  }

  HsPatchData hs_constant_func(InputPatch<HsInput, 1> input)
  {
    float2 worldXZ;
    float size;
    uint edgeFactor;
    getPatchParams(input[0].vertexId, worldXZ, size, edgeFactor);

    uint leftEdge =  (edgeFactor >> TS_EDGE_FACTOR_LEFT) & 0x1;
    uint rightEdge = (edgeFactor >> TS_EDGE_FACTOR_RIGHT) & 0x1;
    uint topEdge =   (edgeFactor >> TS_EDGE_FACTOR_TOP) & 0x1;
    uint botEdge =   (edgeFactor >> TS_EDGE_FACTOR_BOT) & 0x1;

    HsPatchData o;
    o.edges[0] = lerp(TessFactor, TessFactor/2, leftEdge);
    o.edges[1] = lerp(TessFactor, TessFactor/2, topEdge);
    o.edges[2] = lerp(TessFactor, TessFactor/2, rightEdge);
    o.edges[3] = lerp(TessFactor, TessFactor/2, botEdge);
    o.inside[0] = TessFactor;
    o.inside[1] = TessFactor;

    return o;
  }

  struct HsControlPoint
  {
    float4 pos : POSITION0;
  };

  float2 getHeightUV(float2 world_xz)
  {
    // Z               ---------> U
    // ^               |
    // |               |
    // |               v
    // |_________X     V
    //
    float hfSize = TerrainScope.worldMapSize * 0.5;
    float2 uv = ((float2(world_xz.x, -world_xz.y) / hfSize) + 1.0) * 0.5;
    return uv;
  }

  float getHeight(float2 uv)
  {
    float h = heightmap.SampleLevel(linearClampSampler, uv, 0).r;
    
    float minH = TerrainScope.minMaxHeightBorder.x;
    float maxH = TerrainScope.minMaxHeightBorder.y -0.03;
    h = (h - minH) / (maxH - minH) * TerrainScope.maxHeight;

    return h;
  }

  float getHeightFromXZ(float2 world_xz)
  {
    return getHeight(getHeightUV(world_xz));
  }

  [domain("quad")]
  [partitioning("integer")]
  [outputtopology("triangle_ccw")]
  [outputcontrolpoints(4)]
  [patchconstantfunc("hs_constant_func")]
  HsControlPoint hs_main(InputPatch<HsInput, 1> input, uint cpId: SV_OutputControlPointID)
  {
    float2 worldXZ;
    float size;
    uint edgeFactor;
    getPatchParams(input[0].vertexId, worldXZ, size, edgeFactor);

    // [1]------[2]
    //  |        |
    // [0]------[3]
    float2 offsets[4] = {
      float2(0.0, -1.0), 
      float2(0.0, 0.0),
      float2(1.0, 0.0),
      float2(1.0, -1.0)
    };

    float2 cpWorldXZ = worldXZ + offsets[cpId] * size;

    HsControlPoint o;
    o.pos = float4(cpWorldXZ.x, 0.0, cpWorldXZ.y, 1.0);

    return o;
  }

  struct VsOutput
  {
    float4 pos : SV_Position;
    float3 normal : TEXTURE0;
    float2 uv : TEXTURE1;
    float4 prevPos : TEXTURE2;
    float4 curPos : TEXTURE3;
    float3 worldPos: TEXTURE4;
  };

  float3 getPatchNormal(float2 uv)
  {
    float px = 1.0 / TerrainScope.worldMapSize;

    float T = getHeight(uv + px * float2( 0,-1));
    float B = getHeight(uv + px * float2( 0, 1));
    float R = getHeight(uv + px * float2( 1, 0));
    float L = getHeight(uv + px * float2(-1, 0));

    return normalize(float3((R-L), 1.0 , B-T));
  }

  [domain("quad")]
  VsOutput ds_main(HsPatchData patch_data, const OutputPatch<HsControlPoint, 4> cpoints, float2 uv : SV_DomainLocation)
  {
    float4 bot = lerp(cpoints[0].pos, cpoints[3].pos, uv.x);
    float4 top = lerp(cpoints[1].pos, cpoints[2].pos, uv.x);
    float4 p = lerp(bot,top,uv.y);

    float2 heightUV = getHeightUV(p.xz);
    p.y = getHeight(heightUV);

    VsOutput o;
    o.pos = mul(FrameScope.viewProj, p);
    o.normal = getPatchNormal(heightUV);
    o.uv = heightUV;
    o.prevPos = mul(FrameScope.prevViewProj, p);
    o.curPos = o.pos;
    o.worldPos = p.xyz;
    return o;
  }

  PackedMaterial ps_main(VsOutput input)
  {
    UnpackedMaterial m = (UnpackedMaterial)0;

    float3 albedoFallback = fallback.Sample(linearClampSampler, input.uv).rgb;

    float2 worldUV = saturate(((input.worldPos.xz) / TerrainScope.worldMapSize) + 0.5);
    float2 tc = worldUV * VTexParamsScope.vtexSize;
    float2 dx = ddx(tc);
    float2 dy = ddy(tc);
    float mipF = 0.5 * log2(max(dot(dx,dx), dot(dy,dy)));
    uint mip = clamp(mipF, 0.0, VTexParamsScope.maxMip);

    uint vtexMipTileSize = VTexParamsScope.tileSize << mip;
    uint2 vtileXY = (uint2)(tc / vtexMipTileSize);
    float2 vtileUV = tc / float(vtexMipTileSize) - vtileXY;

    uint packedPTile = asuint(indirection.Load(int3(vtileXY, mip)).r);
    uint2 ptile = unpack_ptile(packedPTile);

    float vtexToPhysTexScale = (float)VTexParamsScope.tileSize / VTexParamsScope.tileStorageSize;
    float2 storageTC = ((float2)ptile + vtileUV) * VTexParamsScope.tileSize;
    float2 storageUV = storageTC / VTexParamsScope.tileStorageSize;
    float3 cachedColor = tileStorage.Sample(linearClampSampler, storageUV).rgb;

    uint packedVTile = pack_tile(uint3(vtileXY, mip));
    uint2 feedbackTC = (input.pos.xy - float2(0.5, 0.5)) / FrameScope.viewPortSize * TerrainScope.feedbackSize;
    feedbackBuf[feedbackTC] = packedVTile;

    bool hasCache = packedPTile != (uint)~0;
    float3 fallback = float3(0.1,0.4,0.3);
    float3 color = hasCache ? cachedColor : fallback;

    initAlbedo(m, color);
    //initAlbedo(m, albedoFallback);
    initMetal(m, 0);
    initRoughness(m, 1.0);
    initNormal(m, input.normal);
    initMotionVector(m, input.prevPos, input.curPos, FrameScope.cameraSumJitter);

    return packMaterial(m);
  }
  #end

  compile(vs, vs_main);
  compile(hs, hs_main);
  compile(ds, ds_main);
  compile(ps, ps_main);
};
