#include <frame.inc.tfx>
#include <math.inc.tfx>
#include "atmosphere.inc.tfx"
#include "ebruneton.inc.tfx"
#include "multiple_scattering.inc.tfx"
#include "scattering.inc.tfx"
#include "sky.inc.tfx"
#include "transmittance.inc.tfx"

scope AerialPerspectiveScope {
  reserve:
    descriptor_set(2);
    register(buffer, 0);
    register(texture, 0-2);

  RWTexture3D<float4> apLUT = extern(apLUT);
  Texture2D trLUT = extern(trLUT);
  Texture2D msLUT = extern(msLUT);

  float maxAerialDist_mm = extern(maxAerialDist_mm);
};

technique AerialPerspective {
  support scope FrameScope;
  activate scope AerialPerspectiveScope;
  
  USE_MATH();
  USE_ATMOSPHERE_PARAMS();

  USE_EBRUNETON_HELPERS();
  USE_TRANSMITTANCE_LUT();
  USE_MULTIPLE_SCATTERING_LUT();
  USE_SCATTERING();
  USE_SKY_RAYMARCH();

  #hlsl
  [numthreads(32,32,1)]
  void cs_main(uint3 id: SV_DispatchThreadID)
  {
    AtmosphereParams atmParams = getAtmosphereParams();
    float3 p0_mm = atmParams.posMM;

    float3 ltViewDir = normalize(FrameScope.ltView_WS);
    float3 lbViewDir = normalize(FrameScope.lbView_WS);
    float3 rtViewDir = normalize(FrameScope.rtView_WS);

    float3 lrDir = normalize(FrameScope.rtView_WS - FrameScope.ltView_WS);
    float3 tbDir = normalize(FrameScope.lbView_WS - FrameScope.ltView_WS);

    float3 k = float3(id + uint3(1,1,1)) / 32.0;
    float3 lt_mm = ltViewDir * AerialPerspectiveScope.maxAerialDist_mm * k.z;
    float3 lb_mm = lbViewDir * AerialPerspectiveScope.maxAerialDist_mm * k.z;
    float3 rt_mm = rtViewDir * AerialPerspectiveScope.maxAerialDist_mm * k.z;

    float h_mm = length(lb_mm-lt_mm);
    float w_mm = length(rt_mm-lt_mm);

    float3 froxelVSPos_mm = lt_mm + lrDir * w_mm * k.x + tbDir * h_mm * k.y;
    float3 froxelDir = normalize(froxelVSPos_mm);
    float froxelDist_mm = length(froxelVSPos_mm);
    float3 froxelPos_mm = p0_mm + froxelVSPos_mm;

    float3 RTop_mm;
    float topAtmDist_mm = raySphereIntersection(p0_mm, froxelDir, float3(0,0,0), atmParams.rTopMM, RTop_mm);
  
    float3 RBot_mm;
    float botAtmDist_mm = raySphereIntersection(p0_mm, froxelDir, float3(0,0,0), atmParams.rBotMM, RBot_mm);
  
    float3 sunDir = getAtmSunDir();
    float scatteringDist_mm = min(froxelDist_mm, botAtmDist_mm > 0.0 ? botAtmDist_mm : topAtmDist_mm);

    float3 Tr;
    float3 L = raymarchScattering(p0_mm, scatteringDist_mm, froxelDir, sunDir, atmParams, Tr);

    float a = 1.0 - dot(Tr, Tr * float3(1.0/3.0, 1.0/3.0, 1.0/3.0));

    apLUT[id] = float4(L, a);
  }
  #end

  compile(cs_6_1, cs_main);
};
