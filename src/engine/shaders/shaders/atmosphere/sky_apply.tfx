#include "../depth.inc.tfx"
#include "../frame.inc.tfx"
#include "../math.inc.tfx"
#include "../screen_space.inc.tfx"
#include "atmosphere.inc.tfx"
#include "ebruneton.inc.tfx"
#include "scattering.inc.tfx"
#include "transmittance.inc.tfx"

scope SkyApplyScope {
  reserve:
    descriptor_set(2);
    register(buffer, 0);
    register(texture, 0-3);

  Texture2D skyLUT = extern(skyLUT);
  Texture2D trLUT = extern(trLUT);
  Texture3D apLUT = extern(apLUT);
  Texture2D gbufferDepth = extern(gbufferDepth);

  float maxAerialDist_mm = extern(maxAerialDist_mm);
};

technique SkyApply {
  support scope FrameScope;
  activate scope SkyApplyScope;

  USE_MATH();
  USE_ATMOSPHERE_PARAMS();

  USE_DEPTH_UTILS();
  USE_SCREENSPACE_VIEW_BASE();
  USE_EBRUNETON_HELPERS();
  USE_SCATTERING();
  USE_TRANSMITTANCE_LUT();

  render_state:
    blending:
      mrt(0):
        has_blending = yes;
        src_color_blend_factor = src_alpha;
        dst_color_blend_factor = one_minus_src_alpha;
        color_blend_op = add;

  #hlsl
    float3 calcSunDisk(AtmosphereParams atm_params, float3 view_dir, float3 sun_dir)
    {
      float3 pos = atm_params.posMM;
      float3 RBot_mm;
      float botAtmDist_mm = raySphereIntersection(pos, view_dir, float3(0,0,0), atm_params.rBotMM, RBot_mm);
      if (botAtmDist_mm > 0.0)
        return float3(0.0, 0.0, 0.0);

      float VoL = dot(view_dir, sun_dir);
      float VoZ = view_dir.y;
  
      float sunRadiusMul = 1.3;
      float sunEdgeAngle = 0.5 * sunRadiusMul * PI / 180.0;
      float cosSunEdge = cos(sunEdgeAngle);
      
      if (VoL < cosSunEdge)
          return float3(0.0, 0.0, 0.0);

      float r = (1.0 - VoL) / (1.0 - cosSunEdge);

      float3 a = float3(0.397 , 0.503 , 0.652);
      float3 u = float3(1.0, 1.0, 1.0);
      float limbDarkeningMul = 0.5;
      r = 1.0-r;
      float3 mu = float3(r,r,r)*limbDarkeningMul;

      float3 limbDarkening = 1.0 - u * (1.0 - pow(mu , a));
      float3 sunDisk = limbDarkening * sampleTransmittance(length(pos), VoZ, atm_params.rBotMM, atm_params.rTopMM);
      return sunDisk;
    }

    float4 applySkyLUT(VsOutput input)
    {
      float3 viewDir = normalize(input.viewDir);

      float altitude = PI/2.0 - acos(viewDir.y);
      float2 xzDir = normalize(float2(viewDir.x, viewDir.z));
      float azimuth = fmod(atan2(xzDir.x, xzDir.y) + 2*PI, 2*PI);

      float v = altitude >= 0.0 ? 0.5 + 0.5 * sqrt(altitude / (PI/2.0))
                                : 0.5 - 0.5 * sqrt(abs(altitude) / (PI/2.0));
    
      float u = azimuth / (2.0 * PI);
      float2 uv = float2(u,v);

      AtmosphereParams atmParams = getAtmosphereParams();
      float3 sunDir = getAtmSunDir();
      float3 L = skyLUT.Sample(linearClampSampler, uv).rgb
               + calcSunDisk(atmParams, viewDir, sunDir);
      
      return float4(L, 1.0);
    }

    float4 applyAerialPerspective(VsOutput input, float depth)
    {
      float3 vsPos = calcViewSpacePos(input.viewDir, depth, FrameScope.zNear_zFar.x, FrameScope.zNear_zFar.y);
      float vsPosDist_mm = length(vsPos) / 1e6;

      float u = (input.viewDir.x - FrameScope.ltView.x) / (FrameScope.rtView.x - FrameScope.ltView.x);
      float v = (input.viewDir.y - FrameScope.ltView.y) / (FrameScope.lbView.y - FrameScope.ltView.y);
      float w = saturate(vsPosDist_mm / SkyApplyScope.maxAerialDist_mm);

      return apLUT.Sample(linearClampSampler, float3(u,v,w));
    }

    float4 ps_main(VsOutput input) : SV_Target0
    {
      float depth = gbufferDepth.Load(float3(input.pos.xy, 0)).r;

      if (depth > 0.0)
        return applyAerialPerspective(input, depth);
      else
        return applySkyLUT(input);
    }
  #end

  compile(vs_6_1, vs_main);
  compile(ps_6_1, ps_main);
};
