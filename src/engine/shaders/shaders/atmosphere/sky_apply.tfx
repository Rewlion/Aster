#include "../frame.inc.tfx"
#include "../math.inc.tfx"
#include "../screen_space.inc.tfx"
#include "atmosphere.inc.tfx"
#include "ebruneton.inc.tfx"
#include "scattering.inc.tfx"
#include "transmittance.inc.tfx"

scope SkyApplyScope {
  reserve:
    descriptor_set(2);
    register(texture, 0-1);

  Texture2D skyLUT = extern(skyLUT);
  Texture2D trLUT = extern(trLUT);
};

technique SkyApply {
  support scope FrameScope;
  USE_ATMOSPHERE_PARAMS();
  activate scope SkyApplyScope;

  USE_SCREENSPACE_VIEW_BASE();
  render_state:
    depth:
      test = yes;
      compare_op = equal;

  USE_MATH();
  USE_EBRUNETON_HELPERS();
  USE_SCATTERING();
  USE_TRANSMITTANCE_LUT();

  #hlsl
    float3 calcSunDisk(AtmosphereParams atm_params, float3 view_dir, float3 sun_dir)
    {
      float3 pos = float3(0.0, atm_params.rBotMM + 0.0002, 0.0);
      float3 RBot_mm;
      float botAtmDist_mm = raySphereIntersection(pos, view_dir, float3(0,0,0), atm_params.rBotMM, RBot_mm);
      if (botAtmDist_mm > 0.0)
        return float3(0.0, 0.0, 0.0);

      float VoL = dot(view_dir, sun_dir);
      float VoZ = view_dir.y;
  
      float sunRadiusMul = 1.3;
      float sunEdgeAngle = 0.5 * sunRadiusMul * PI / 180.0;
      float cosSunEdge = cos(sunEdgeAngle);
      
      if (VoL < cosSunEdge)
          return float3(0.0, 0.0, 0.0);

      float r = (1.0 - VoL) / (1.0 - cosSunEdge);

      float3 a = float3(0.397 , 0.503 , 0.652);
      float3 u = float3(1.0, 1.0, 1.0);
      float limbDarkeningMul = 0.5;
      r = 1.0-r;
      float3 mu = float3(r,r,r)*limbDarkeningMul;

      float3 limbDarkening = 1.0 - u * (1.0 - pow(mu , a));
      float3 sunDisk = limbDarkening * sampleTransmittance(length(pos), VoZ, atm_params.rBotMM, atm_params.rTopMM);
      return sunDisk;
    }

    float3 ps_main(VsOutput input) : SV_Target0
    {
      float3 viewDir = normalize(input.viewDir);

      float altitude = PI/2.0 - acos(viewDir.y);
      float2 xzDir = normalize(float2(viewDir.x, viewDir.z));
      float azimuth = fmod(atan2(xzDir.x, xzDir.y) + 2*PI, 2*PI);

      float v = altitude >= 0.0 ? 0.5 + 0.5 * sqrt(altitude / (PI/2.0))
                                : 0.5 - 0.5 * sqrt(abs(altitude) / (PI/2.0));
    
      float u = azimuth / (2.0 * PI);
      float2 uv = float2(u,v);

      AtmosphereParams atmParams = getAtmosphereParams();
      float3 sunDir = altitudeAzimuthToDecartian(AtmosphereScope.sunAzimuth_Altitude.y, AtmosphereScope.sunAzimuth_Altitude.x);

      float3 L = skyLUT.Sample(linearClampSampler, uv).rgb
               + calcSunDisk(atmParams, viewDir, sunDir);

      return L;
    }
  #end

  compile(vs_6_1, vs_main);
  compile(ps_6_1, ps_main);
};
