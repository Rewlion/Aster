#include "ebruneton.inc.tfx"
#include "common.inc.tfx"
#include "../frame.inc.tfx"

scope SkyApplyScope {
  reserve:
    descriptor_set(2);
    register(texture, 0-1);

  Texture2D skyLUT = extern(skyLUT);
  Texture2D trLUT = extern(trLUT);
};

technique SkyApply {
  support scope FrameScope;
  support scope AtmosphereScope;
  support scope SkyApplyScope;

   render_state:
    primitive_topology = triangle_strip;
    depth:
     test = yes;
     write = no;
     compare_op = equal;

  USE_EBRUNETON_HELPERS();
  USE_ATMOSPHERE_COMMON();

  #hlsl
    #include "consts.hlsl"

    struct VsOutput
    {
      float4 pos: SV_Position;
      float3 viewDir: POSITION0;
    };

    VsOutput vs_main(uint id: SV_VertexID)
    {
      float2 vertices[4] = {
        float2(1.0f, -1.0f),
        float2(-1.0f, -1.0f),
        float2(1.0f, 1.0f),
        float2(-1.0f, 1.0f)
      };

      float3 frustumViews[4] = {
        FrameScope.rbView,
        FrameScope.lbView,
        FrameScope.rtView,
        FrameScope.ltView
      };

      VsOutput output;
      output.pos = float4(vertices[id], 0.0, 1.0);
      output.viewDir = frustumViews[id];
      
      return output;
    }

    #define PI (float)3.14159265359

    float3 sampleTransmittance(float r_mm, float mu, float atm_bot_radius, float atm_top_radius)
    {
     float2 uv = GetTransmittanceTextureUvFromRMu(TR_LUT_SIZE, r_mm, mu, atm_bot_radius, atm_top_radius);
     return trLUT.Sample(linearClampSampler, uv).rgb;
    }

    float3 calcSunDisk(AtmosphereParams atm_params, float3 viewDir, float3 sunDir)
    {
      float3 pos = float3(0.0, atm_params.rBotMM + 0.0002, 0.0);
      float3 RBot_mm;
      float botAtmDist_mm = raySphereIntersection(pos, viewDir, float3(0,0,0), atm_params.rBotMM, RBot_mm);
      if (botAtmDist_mm > 0.0)
        return float3(0.0, 0.0, 0.0);

      float VoL = dot(viewDir, sunDir);
      float VoZ = viewDir.y;
  
      float sunRadiusMul = 1.3;
      float sunEdgeAngle = 0.5 * sunRadiusMul * PI / 180.0;
      float cosSunEdge = cos(sunEdgeAngle);
      
      if (VoL < cosSunEdge)
          return float3(0.0, 0.0, 0.0);

      float r = (1.0 - VoL) / (1.0 - cosSunEdge);

      float3 a = float3(0.397 , 0.503 , 0.652);
      float3 u = float3(1.0, 1.0, 1.0);
      float limbDarkeningMul = 0.5;
      r = 1.0-r;
      float3 mu = float3(r,r,r)*limbDarkeningMul;

      float3 limbDarkening = 1.0 - u * (1.0 - pow(mu , a));
      float3 sunDisk = limbDarkening * sampleTransmittance(length(pos), VoZ, atm_params.rBotMM, atm_params.rTopMM);
      return sunDisk;
    }

    float3 altitudeAzimuthToDecartian(float altitude, float azimuth)
    {
      return normalize(float3(cos(altitude)*sin(azimuth),
                    sin(altitude),
                    cos(altitude)*cos(azimuth)));
    }

    float3 ps_main(VsOutput input) : SV_Target0
    {
      float3 viewDir = normalize(input.viewDir);

      float altitude = PI/2.0 - acos(viewDir.y);
      float2 xzDir = normalize(float2(viewDir.x, viewDir.z));
      float azimuth = fmod(atan2(xzDir.x, xzDir.y) + 2*PI, 2*PI);

      float v = altitude >= 0.0 ? 0.5 + 0.5 * sqrt(altitude / (PI/2.0))
                                : 0.5 - 0.5 * sqrt(abs(altitude) / (PI/2.0));
    
      float u = azimuth / (2.0 * PI);
      float2 uv = float2(u,v);

      AtmosphereParams atmParams = getAtmosphereParams();
      float3 sunDir = altitudeAzimuthToDecartian(AtmosphereScope.sunAzimuth_Altitude.y, AtmosphereScope.sunAzimuth_Altitude.x);

      float3 L = skyLUT.Sample(linearClampSampler, uv).rgb
               + calcSunDisk(atmParams, viewDir, sunDir);

      return L;
    }
  #end

  compile(vs_6_1, vs_main);
  compile(ps_6_1, ps_main);
};
