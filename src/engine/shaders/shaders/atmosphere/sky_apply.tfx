#include "ebruneton.inc.tfx"
#include "common.inc.tfx"
#include "../frame.inc.tfx"

scope SkyApplyScope {
  reserve:
    descriptor_set(2);
    register(texture, 0);

  Texture2D skyLUT = extern(skyLUT);
};

technique SkyApply {
  support scope FrameScope;
  support scope SkyApplyScope;

   render_state:
    primitive_topology = triangle_strip;
    depth:
     test = yes;
     write = no;
     compare_op = equal;

  #hlsl
    struct VsOutput
    {
      float4 pos: SV_Position;
      float3 viewDir: POSITION0;
    };

    VsOutput vs_main(uint id: SV_VertexID)
    {
      float2 vertices[4] = {
        float2(1.0f, -1.0f),
        float2(-1.0f, -1.0f),
        float2(1.0f, 1.0f),
        float2(-1.0f, 1.0f)
      };

      float3 frustumViews[4] = {
        FrameScope.rtView,
        FrameScope.ltView,
        FrameScope.rbView,
        FrameScope.lbView
      };

      VsOutput output;
      output.pos = float4(vertices[id], 0.0, 1.0);
      output.viewDir = frustumViews[id];
      
      return output;
    }

    #define PI (float)3.14159265359

    float3 ps_main(VsOutput input) : SV_Target0
    {
      float3 viewDir = normalize(input.viewDir);

      float altitude = PI/2.0 - acos(-viewDir.y);
      float2 xzDir = normalize(float2(viewDir.x, viewDir.z));
      float azimuth = fmod(atan2(xzDir.x, xzDir.y) + 2*PI, 2*PI);

      float v = altitude >= 0.0 ? 0.5 + 0.5 * sqrt(altitude / (PI/2.0))
                                : 0.5 - 0.5 * sqrt(abs(altitude) / (PI/2.0));
      float u = azimuth / (2.0 * PI);
      float2 uv = float2(u,v);

      float3 L = skyLUT.Sample(linearClampSampler, uv).rgb;
      return L;
    }
  #end

  compile(vs_6_1, vs_main);
  compile(ps_6_1, ps_main);
};
