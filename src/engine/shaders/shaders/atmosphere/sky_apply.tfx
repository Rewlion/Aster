#include <depth.inc.tfx>
#include <frame.inc.tfx>
#include <math.inc.tfx>
#include <screen_space.inc.tfx>
#include "atmosphere.inc.tfx"
#include "ebruneton.inc.tfx"
#include "scattering.inc.tfx"
#include "transmittance.inc.tfx"
#include "sky.inc.tfx"

scope SkyApplyScope {
  reserve:
    descriptor_set(2);
    register(buffer, 0);
    register(texture, 0-3);

  Texture2D skyLUT = extern(skyLUT);
  Texture2D trLUT = extern(trLUT);
  Texture3D apLUT = extern(apLUT);
  Texture2D gbufferDepth = extern(gbufferDepth);

  float maxAerialDist_mm = extern(maxAerialDist_mm);
};

technique SkyApply {
  support scope FrameScope;
  activate scope SkyApplyScope;

  USE_MATH();
  USE_ATMOSPHERE_PARAMS();

  USE_DEPTH_UTILS();
  USE_SCREENSPACE_VIEW_BASE();
  USE_EBRUNETON_HELPERS();
  USE_SCATTERING();
  USE_TRANSMITTANCE_LUT();
  USE_SKY_LUT();

  render_state:
    blending:
      mrt(0):
        has_blending = yes;
        src_color_blend_factor = src_alpha;
        dst_color_blend_factor = one_minus_src_alpha;
        color_blend_op = add;

  #hlsl
    float4 applySkyLUT(VsOutput input)
    {
      float3 viewDir = normalize(input.viewDir);

      AtmosphereParams atmParams = getAtmosphereParams();
      float3 sunDir = getAtmSunDir();
      float3 L = sampleFullSky(atmParams, viewDir, sunDir);
      
      return float4(L, 1.0);
    }

    float4 applyAerialPerspective(VsOutput input, float depth)
    {
      float3 vsPos = interpolateFarPlanePoint(input.viewDir, depth, FrameScope.zNear_zFar.x, FrameScope.zNear_zFar.y);
      float vsPosDist_mm = length(vsPos) / 1e6;

      float u = (input.viewDir.x - FrameScope.ltView_WS.x) / (FrameScope.rtView_WS.x - FrameScope.ltView_WS.x);
      float v = (input.viewDir.y - FrameScope.ltView_WS.y) / (FrameScope.lbView_WS.y - FrameScope.ltView_WS.y);
      float w = saturate(vsPosDist_mm / SkyApplyScope.maxAerialDist_mm);

      return apLUT.Sample(linearClampSampler, float3(u,v,w));
    }

    float4 ps_main(VsOutput input) : SV_Target0
    {
      float depth = gbufferDepth.Load(float3(input.pos.xy, 0)).r;

      [BRANCH]
      if (depth > 0.0)
        return applyAerialPerspective(input, depth);
      else
        return applySkyLUT(input);
    }
  #end

  compile(vs_6_1, vs_main);
  compile(ps_6_1, ps_main);
};
