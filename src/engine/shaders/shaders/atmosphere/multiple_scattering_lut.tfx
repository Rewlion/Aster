#include "ebruneton.inc.tfx"
#include "common.inc.tfx"
#include "../frame.inc.tfx"

scope MsLUTScope {
  reserve:
    descriptor_set(2);
    register(texture, 0);

  Texture2D trLUT = extern(trLUT);
};

technique MultipleScatteringLUT {
  support scope FrameScope;
  support scope AtmosphereScope;
  activate scope MsLUTScope;

  render_state:
    primitive_topology = triangle_strip;
    depth:
     test = no;
     write = no;

  USE_EBRUNETON_HELPERS();
  USE_ATMOSPHERE_COMMON();

  #hlsl
    #include "consts.hlsl"

    struct VsOutput
    {
      float4 pos: SV_Position;
    };

    float4 vs_main(uint id: SV_VertexID) : SV_Position
    {
      float2 vertices[4] = {
        float2(1.0f, -1.0f),
        float2(-1.0f, -1.0f),
        float2(1.0f, 1.0f),
        float2(-1.0f, 1.0f)
      };

      return float4(vertices[id], 0, 1.0);
    }

    float3 sphericalToDecart(float theta, float phi)
    {
      return float3(
        sin(theta)*cos(phi),
        sin(theta)*sin(phi),
        cos(theta)
      );
    }

    float3 sampleTransmittance(float r_mm, float mu, float atm_bot_radius, float atm_top_radius)
    {
     float2 uv = GetTransmittanceTextureUvFromRMu(TR_LUT_SIZE, r_mm, mu, atm_bot_radius, atm_top_radius);
     return trLUT.Sample(linearClampSampler, uv).rgb;
    }
    
    void calcMultipleScattering(AtmosphereParams atmParams, float3 p0_mm, float3 lightDir, out float3 psi)
    {
      psi = float3(0,0,0);
    
      float sqrtN = 8.0;
      float invN = 1.0 / (sqrtN*sqrtN);
      float3 fms = float3(0,0,0);
      float3 L2 = float3(0,0,0);
      
      for (float i = 0.0; i < sqrtN; i += 1.0)
      for (float j = 0.0; j < sqrtN; j += 1.0)
      {
        float theta = acos(clamp(1.0 - 2.0 * j/sqrtN, -1.0, 1.0));
        float phi = 2.0 * PI * i /sqrtN;
        float3 viewDir = sphericalToDecart(theta, phi);
        
        float VoL = dot(viewDir, lightDir);
      
        float rayPhase = phaseR(VoL);
        float miePhase = phaseM_HG(VoL, 0.76);
        
        float3 RTop_mm;
        float topAtmDist_mm = raySphereIntersection(p0_mm, viewDir, float3(0,0,0), atmParams.rTopMM, RTop_mm);
        
        float3 RBot_mm;
        float botAtmDist_mm = raySphereIntersection(p0_mm, viewDir, float3(0,0,0), atmParams.rBotMM, RBot_mm);
        
        float scatteringDist_mm = botAtmDist_mm > 0.0 ? botAtmDist_mm : topAtmDist_mm;
        
        float3 Tr = float3(1,1,1);
        float t = 0.0;
        float3 fmsi = float3(0,0,0);
        float3 L2i = float3(0,0,0);
        for (float i = 0.0; i < MSCATTERING_STEPS; i += 1.0)
        {
          float newT = (i+0.3)/MSCATTERING_STEPS * scatteringDist_mm;
          float dt = newT - t;
          t = newT;
          
          float3 Ri_mm = p0_mm + viewDir * t;
          float3 RiDir = normalize(Ri_mm);
          float Ri_len_mm = length(Ri_mm);
          float RioSDir = dot(RiDir, lightDir);
        
          float3 rayScattering, extintion;
          float3 mieScattering;
          calcScatteringValues(atmParams, Ri_mm, rayScattering, mieScattering, extintion);
          
          float3 Tri = exp(-extintion * dt);
          float3 TrSun = sampleTransmittance(Ri_len_mm, RioSDir, atmParams.rBotMM, atmParams.rTopMM);
          
          float3 Sfi = rayScattering + mieScattering;
          fmsi += (Sfi * (1.0 - Tri) / extintion) * Tr;
        
          float3 Si = (rayPhase * rayScattering + miePhase * mieScattering) * TrSun;
          L2i += (Si*(1.0 -  Tri) / extintion) * Tr;
          
          Tr *= Tri;
        }
      
        fms += fmsi * invN / (4.0*PI);
        L2 += L2i * invN;
      }
      
      psi = L2 / (1.0 - fms);
    }
    
    float3 ps_main(VsOutput input) : SV_Target0
    {
      float2 uv = input.pos.xy/MS_LUT_SIZE;

      AtmosphereParams atmParams = getAtmosphereParams();
      float r = lerp(atmParams.rBotMM, atmParams.rTopMM, uv.y);
      float sunZenith = clamp(1.0 - 2.0*uv.x, -1.0, 1.0);
      
      float3 p0_mm = float3(0,r,0);
      float sinSunZenith = sqrt(1.0-sunZenith*sunZenith);
      float3 lightDir = normalize(float3(0, sunZenith, sinSunZenith));
      
      float3 psi;
      calcMultipleScattering(atmParams, p0_mm, lightDir, psi);

      return psi;
    }
  #end

  compile(vs_6_1, vs_main);
  compile(ps_6_1, ps_main);
};
