#include <frame.inc.tfx>
#include <math.inc.tfx>
#include <screen_space.inc.tfx>
#include "atmosphere.inc.tfx"
#include "ebruneton.inc.tfx"
#include "scattering.inc.tfx"
#include "transmittance.inc.tfx"

scope MsLUTScope {
  reserve:
    descriptor_set(2);
    register(texture, 0);

  Texture2D trLUT = extern(trLUT);
};

technique MultipleScatteringLUT {
  support scope FrameScope;
  USE_ATMOSPHERE_PARAMS();
  activate scope MsLUTScope;

  USE_MATH();
  USE_EBRUNETON_HELPERS();
  USE_SCATTERING();
  USE_TRANSMITTANCE_LUT();
  USE_SCREENSPACE_BASE();

  #hlsl
    void calcMultipleScattering(AtmosphereParams atm_params, float3 p0_mm, float3 light_dir, out float3 psi)
    {
      psi = float3(0,0,0);
    
      float sqrtN = 8.0;
      float invN = 1.0 / (sqrtN*sqrtN);
      float3 fms = float3(0,0,0);
      float3 L2 = float3(0,0,0);
      
      for (float i = 0.0; i < sqrtN; i += 1.0)
      for (float j = 0.0; j < sqrtN; j += 1.0)
      {
        float theta = acos(clamp(1.0 - 2.0 * j/sqrtN, -1.0, 1.0));
        float phi = 2.0 * PI * i /sqrtN;
        float3 viewDir = sphericalToDecartian(theta, phi);
        
        float VoL = dot(viewDir, light_dir);
      
        float rayPhase = RayleighPhaseFunction(VoL);
        float miePhase = MiePhaseFunction(VoL, 0.76);
        
        float3 RTop_mm;
        float topAtmDist_mm = raySphereIntersection(p0_mm, viewDir, float3(0,0,0), atm_params.rTopMM, RTop_mm);
        
        float3 RBot_mm;
        float botAtmDist_mm = raySphereIntersection(p0_mm, viewDir, float3(0,0,0), atm_params.rBotMM, RBot_mm);
        
        float scatteringDist_mm = botAtmDist_mm > 0.0 ? botAtmDist_mm : topAtmDist_mm;
        
        float3 Tr = float3(1,1,1);
        float t = 0.0;
        float3 fmsi = float3(0,0,0);
        float3 L2i = float3(0,0,0);
        for (float i = 0.0; i < MSCATTERING_STEPS; i += 1.0)
        {
          float newT = (i+0.3)/MSCATTERING_STEPS * scatteringDist_mm;
          float dt = newT - t;
          t = newT;
          
          float3 Ri_mm = p0_mm + viewDir * t;
          float3 RiDir = normalize(Ri_mm);
          float Ri_len_mm = length(Ri_mm);
          float RioSDir = dot(RiDir, light_dir);
        
          float3 rayScattering, extintion;
          float3 mieScattering;
          calcScatteringValues(atm_params, Ri_mm, rayScattering, mieScattering, extintion);
          
          float3 Tri = exp(-extintion * dt);
          float3 TrSun = sampleTransmittance(Ri_len_mm, RioSDir, atm_params.rBotMM, atm_params.rTopMM);
          
          float3 Sfi = rayScattering + mieScattering;
          fmsi += (Sfi * (1.0 - Tri) / extintion) * Tr;
        
          float3 Si = (rayPhase * rayScattering + miePhase * mieScattering) * TrSun;
          L2i += (Si*(1.0 -  Tri) / extintion) * Tr;
          
          Tr *= Tri;
        }
      
        fms += fmsi * invN / (4.0*PI);
        L2 += L2i * invN;
      }
      
      psi = L2 / (1.0 - fms);
    }
    
    float3 ps_main(VsOutput input) : SV_Target0
    {
      float2 uv = input.pos.xy/MS_LUT_SIZE;

      AtmosphereParams atmParams = getAtmosphereParams();
      float r = lerp(atmParams.rBotMM, atmParams.rTopMM, uv.y);
      float sunZenith = clamp(1.0 - 2.0*uv.x, -1.0, 1.0);
      
      float3 p0_mm = float3(0,r,0);
      float sinSunZenith = sqrt(1.0-sunZenith*sunZenith);
      float3 lightDir = normalize(float3(0, sunZenith, sinSunZenith));
      
      float3 psi;
      calcMultipleScattering(atmParams, p0_mm, lightDir, psi);

      return psi;
    }
  #end

  compile(vs_6_1, vs_main);
  compile(ps_6_1, ps_main);
};
