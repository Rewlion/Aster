// this file is generated by ecs codegen
// do not edit
#include <engine/ecs/ecs.h>
#include <engine/ecs/components_accessor.h>
#include <EASTL/functional.h>

#include "frame_preparing.ecs.cpp" 

using namespace ecs;

const static DirectQueryRegistration query_render_prev_far_plane_points_queryReg{
  {
    DESCRIBE_QUERY_COMPONENT("render_prev_lt_view_ws", float3),
    DESCRIBE_QUERY_COMPONENT("render_prev_rt_view_ws", float3),
    DESCRIBE_QUERY_COMPONENT("render_prev_lb_view_ws", float3),
    DESCRIBE_QUERY_COMPONENT("render_prev_rb_view_ws", float3)
  },
  "query_render_prev_far_plane_points"};
const static query_id_t query_render_prev_far_plane_points_queryId = query_render_prev_far_plane_points_queryReg.getId();


void query_render_prev_far_plane_points (eastl::function<
  void(
    float3& render_prev_lt_view_ws,
    float3& render_prev_rt_view_ws,
    float3& render_prev_lb_view_ws,
    float3& render_prev_rb_view_ws)> cb)
{
  ecs::get_registry().query(query_render_prev_far_plane_points_queryId, [&](ComponentsAccessor& accessor)
  {
    float3& render_prev_lt_view_ws = accessor.get<float3>(compile_ecs_name_hash("render_prev_lt_view_ws"));
    float3& render_prev_rt_view_ws = accessor.get<float3>(compile_ecs_name_hash("render_prev_rt_view_ws"));
    float3& render_prev_lb_view_ws = accessor.get<float3>(compile_ecs_name_hash("render_prev_lb_view_ws"));
    float3& render_prev_rb_view_ws = accessor.get<float3>(compile_ecs_name_hash("render_prev_rb_view_ws"));
    cb(render_prev_lt_view_ws,render_prev_rt_view_ws,render_prev_lb_view_ws,render_prev_rb_view_ws);
  });
}


//Engine::OnFrameGraphInit handler
static
void mk_fg_node_backbuffer_acquiring(Event*, ComponentsAccessor&)
{
  fg::register_node("backbuffer_acquiring", FG_FILE_DECL, [](fg::Registry& reg)
  { 
    auto backbuffer = reg.importTextureProducer("backbuffer", import_backbuffer);

    return [](gapi::CmdEncoder& encoder)
    {
      backbuffer_acquiring_exec(encoder);
    };
  });
}

static
EventSystemRegistration mk_fg_node_backbuffer_acquiring_registration(
  mk_fg_node_backbuffer_acquiring,
  compile_ecs_name_hash("OnFrameGraphInit"),
  {
  },
  "mk_fg_node_backbuffer_acquiring"
);


static void mk_frame_samplers_preparing_node_internal(Event* event, ComponentsAccessor& accessor)
{
  const Engine::OnFrameGraphInit* casted_event = reinterpret_cast<const Engine::OnFrameGraphInit*>(event);

  mk_frame_samplers_preparing_node(*casted_event);
}


static EventSystemRegistration mk_frame_samplers_preparing_node_registration(
  mk_frame_samplers_preparing_node_internal,
  compile_ecs_name_hash("OnFrameGraphInit"),
  {

  },
  "mk_frame_samplers_preparing_node"
);


//Engine::OnFrameGraphInit handler
static
void mk_fg_node_frame_preparing(Event*, ComponentsAccessor&)
{
  fg::register_node("frame_preparing", FG_FILE_DECL, [](fg::Registry& reg)
  { 
    reg.orderMeAfter("backbuffer_acquiring");
    auto sph_buf = reg.createBuffer(
      "sph_buf",
      gapi::BufferAllocationDescription{
        .size = (9 + 1) * sizeof(float4),
        .usage = gapi::BufferUsage::BF_BindUAV | gapi::BufferUsage::BF_GpuVisible
      },
      gapi::BufferState::BF_STATE_UAV_RW
    );
    auto camera_data = reg.createBlob<Engine::CameraData>("camera_data");
    auto window_size = reg.createBlob<int2>("window_size");

    return [sph_buf,camera_data,window_size](gapi::CmdEncoder& encoder)
    {
      frame_preparing_exec(encoder, sph_buf.get(), camera_data.get(), window_size.get());
    };
  });
}

static
EventSystemRegistration mk_fg_node_frame_preparing_registration(
  mk_fg_node_frame_preparing,
  compile_ecs_name_hash("OnFrameGraphInit"),
  {
  },
  "mk_fg_node_frame_preparing"
);
